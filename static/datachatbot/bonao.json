{
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn lên": "std::vector<int> parseAndCeilFloatsByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "class": "lớp trong lập trình hướng đối tượng",
    "object": "đối tượng của lớp",
    "function": "tập hợp các lệnh thực hiện",
    "array": "mảng lưu trữ danh sách các phần tử",
    "pointer": "biến lưu địa chỉ của biến khác",
    "reference": "tên mới cho biến",
    "template": "kỹ thuật lập trình tổng quát",
    "namespace": "không gian tên để tránh xung đột",
    "operator": "toán tử thực hiện phép toán",
    "constructor": "hàm khởi tạo đối tượng",
    "destructor": "hàm hủy đối tượng",
    "inheritance": "kế thừa thuộc tính và phương thức",
    "polymorphism": "đa hình cho phép một tên nhiều nghĩa",
    "encapsulation": "đóng gói dữ liệu và phương thức",
    "abstraction": "trừu tượng hóa chi tiết thừa thãi",
    "algorithm": "thuật toán chuỗi bước giải quyết",
    "exception handling": "xử lý ngoại lệ",
    "file handling": "quản lý đọc ghi file",
    "dynamic memory": "bộ nhớ cấp phát giải phóng khi chạy",
    "stack": "bộ nhớ hoạt động kiểu lifo",
    "heap": "bộ nhớ động cấp phát giải phóng tự do",
    "linked list": "danh sách liên kết",
    "binary tree": "cây nhị phân",
    "graph": "đồ thị tập hợp đỉnh cạnh",
    "hash table": "bảng băm lưu trữ dữ liệu theo khóa",
    "serialization": "lưu trữ và đọc dữ liệu",
    "deserialization": "chuyển đổi dữ liệu về dạng gốc",
    "multithreading": "chạy đồng thời",
    "synchronization": "đồng bộ dữ liệu giữa các luồng",
    "mutex": "biến đồng bộ",
    "semaphore": "biến đồng bộ nhiều luồng",
    "lambda expression": "biểu thức lambda hàm vô danh",
    "algorithm": "thuật toán",
    "dynamic_cast": "cast động",
    "static_cast": "cast tĩnh",
    "const_cast": "cast hằng",
    "reinterpret_cast": "cast chuyển đổi kiểu",
    "template specialization": "chuyên biệt hóa mẫu",
    "virtual function": "hàm ảo",
    "pure virtual function": "hàm ảo thuần túy",
    "abstract class": "lớp trừu tượng",
    "interface": "giao diện",
    "module": "mô-đun",
    "namespace": "không gian tên",
    "inheritance": "kế thừa",
    "friend class": "lớp bạn",
    "friend function": "hàm bạn",
    "operator overloading": "nạp chồng toán tử",
    "function overloading": "nạp chồng hàm",
    "multiple inheritance": "kế thừa đa kế thừa",
    "single inheritance": "kế thừa đơn",
    "diamond problem": "vấn đề kim cương",
    "template metaprogramming": "lập trình meta mẫu",
    "type traits": "đặc tính kiểu",
    "type casting": "chuyển kiểu",
    "dynamic allocation": "cấp phát động",
    "static allocation": "cấp phát tĩnh",
    "memory leak": "rò rỉ bộ nhớ",
    "garbage collection": "thu gom rác",
    "RAII": "quản lý tài nguyên thông qua đời sống đối tượng",
    "move semantics": "ngữ nghĩa di chuyển",
    "copy constructor": "hàm xây dựng sao chép",
    "assignment operator": "toán tử gán",
    "overriding": "ghi đè",
    "overloading": "nạp chồng",
    "template class": "lớp mẫu",
    "template function": "hàm mẫu",
    "const": "biến không thay đổi giá trị",
    "static": "biến hoặc hàm có phạm vi trong lớp hoặc tệp",
    "volatile": "biến có thể thay đổi bất cứ lúc nào ngoài tầm kiểm soát của chương trình",
    "extern": "biến hoặc hàm được định nghĩa ở nơi khác",
    "inline": "hàm được định nghĩa trong cùng tệp nguồn để tối ưu hóa hiệu suất",
    "namespace std": "không gian tên tiêu chuẩn trong C++",
    "auto": "kiểu dữ liệu tự động suy luận",
    "decltype": "xác định kiểu dữ liệu của biểu thức",
    "dynamic_cast": "chuyển đổi kiểu động",
    "static_cast": "chuyển đổi kiểu tĩnh",
    "const_cast": "chuyển đổi kiểu hằng",
    "reinterpret_cast": "chuyển đổi kiểu reinterpret",
    "template specialization": "chuyên biệt hóa mẫu",
    "virtual destructor": "hàm hủy ảo",
    "abstract base class": "lớp cơ sở trừu tượng",
    "smart pointer": "con trỏ thông minh quản lý bộ nhớ tự động",
    "unique_ptr": "con trỏ thông minh sở hữu độc quyền",
    "shared_ptr": "con trỏ thông minh chia sẻ quyền sở hữu",
    "weak_ptr": "con trỏ thông minh không sở hữu",
    "move constructor": "hàm xây dựng di chuyển",
    "move assignment operator": "toán tử gán di chuyển",
    "copy assignment operator": "toán tử gán sao chép",
    "overload resolution": "giải quyết nạp chồng",
    "operator function": "hàm toán tử",
    "template argument deduction": "suy luận đối số mẫu",
    "function template": "mẫu hàm",
    "class template": "mẫu lớp",
    "type trait": "đặc tính kiểu",
    "type alias": "bí danh kiểu",
    "preprocessor directive": "chỉ thị tiền xử lý",
    "macro": "macro tiền xử lý",
    "include guard": "bảo vệ bao gồm",
    "typeid": "xác định kiểu dữ liệu",
    "dynamic memory allocation": "cấp phát bộ nhớ động",
    "memory management": "quản lý bộ nhớ",
    "virtual function table": "bảng hàm ảo",
    "function object": "đối tượng hàm",
    "functor": "đối tượng hàm",
    "lambda function": "hàm lambda",
    "thread": "luồng thực thi song song",
    "mutex": "biến đồng bộ",
    "condition variable": "biến điều kiện",
    "atomic operation": "phép toán nguyên tử",
    "async": "thực hiện bất đồng bộ",
    "promise": "hứa hẹn trong lập trình đa luồng",
    "future": "tương lai trong lập trình đa luồng",
    "algorithm library": "thư viện thuật toán",
    "container": "cấu trúc lưu trữ dữ liệu",
    "iterator": "bộ lặp",
    "algorithm complexity": "độ phức tạp thuật toán",
    "big O notation": "ký hiệu độ phức tạp thuật toán",
    "sorting algorithm": "thuật toán sắp xếp",
    "search algorithm": "thuật toán tìm kiếm",
    "graph traversal": "duyệt đồ thị",
    "dynamic programming": "lập trình động",
    "greedy algorithm": "thuật toán tham lam",
    "function pointer": "con trỏ hàm",
    "callback function": "hàm gọi lại",
    "exception handling": "xử lý ngoại lệ",
    "try block": "khối thử",
    "catch block": "khối bắt",
    "throw keyword": "từ khóa ném",
    "assert macro": "macro kiểm tra điều kiện",
    "memory leak": "rò rỉ bộ nhớ",
    "garbage collection": "thu gom rác",
    "resource management": "quản lý tài nguyên",
    "RAII": "quản lý tài nguyên qua đời sống đối tượng",
    "compile-time polymorphism": "đa hình thời gian biên dịch",
    "runtime polymorphism": "đa hình thời gian chạy",
    "function overloading": "nạp chồng hàm",
    "operator overloading": "nạp chồng toán tử",
    "friend function": "hàm bạn",
    "friend class": "lớp bạn",
    "multiple inheritance": "kế thừa đa cấp",
    "virtual inheritance": "kế thừa ảo",
    "diamond problem": "vấn đề kim cương",
    "pure virtual function": "hàm ảo thuần túy",
    "abstract class": "lớp trừu tượng",
    "interface class": "lớp giao diện",
    "type conversion": "chuyển đổi kiểu",
    "type casting": "chuyển kiểu",
    "dynamic_cast": "chuyển kiểu động",
    "static_cast": "chuyển kiểu tĩnh",
    "const_cast": "chuyển kiểu hằng",
    "reinterpret_cast": "chuyển kiểu reinterpret",
    "template class": "lớp mẫu",
    "template function": "hàm mẫu",
    "function template": "mẫu hàm",
    "class template": "mẫu lớp",
    "template specialization": "chuyên biệt hóa mẫu",
    "template instantiation": "cấp phát mẫu",
    "type traits": "đặc tính kiểu",
    "type alias": "bí danh kiểu",
    "preprocessor directive": "chỉ thị tiền xử lý",
    "macro substitution": "thay thế macro",
    "include guard": "bảo vệ bao gồm",
    "file stream": "luồng tệp",
    "input stream": "luồng đầu vào",
    "output stream": "luồng đầu ra",
    "string stream": "luồng chuỗi",
    "serialization": "tuần tự hóa dữ liệu",
    "deserialization": "giải tuần tự hóa dữ liệu",
    "file handling": "quản lý tệp",
    "file operations": "hoạt động trên tệp",
    "binary file": "tệp nhị phân",
    "text file": "tệp văn bản",
    "buffer overflow": "tràn bộ đệm",
    "stack overflow": "tràn ngăn xếp",
    "heap overflow": "tràn bộ nhớ động",
    "data race": "cuộc đua dữ liệu",
    "thread safety": "an toàn luồng",
    "mutex lock": "khóa mutex",
    "condition variable": "biến điều kiện",
    "atomic variable": "biến nguyên tử",
    "thread synchronization": "đồng bộ luồng",
    "deadlock": "tình trạng chết lâm sàng",
    "livelock": "tình trạng sống động",
    "race condition": "tình trạng đua",
    "lock-free data structure": "cấu trúc dữ liệu không khóa",
    "memory model": "mô hình bộ nhớ",
    "functional programming": "lập trình hàm",
    "object-oriented programming": "lập trình hướng đối tượng",
    "procedural programming": "lập trình theo quy trình",
    "generic programming": "lập trình tổng quát",
    "design pattern": "mẫu thiết kế",
    "singleton pattern": "mẫu đơn lẻ",
    "factory pattern": "mẫu nhà máy",
    "observer pattern": "mẫu quan sát",
    "strategy pattern": "mẫu chiến lược",
    "adapter pattern": "mẫu bộ điều hợp",
    "decorator pattern": "mẫu trang trí",
    "command pattern": "mẫu lệnh",
    "proxy pattern": "mẫu đại diện",
    "composite pattern": "mẫu tổ hợp",
    "builder pattern": "mẫu xây dựng",
    "prototype pattern": "mẫu nguyên mẫu",
    "biến toàn cục": "biến có phạm vi toàn bộ chương trình",
    "biến cục bộ": "biến chỉ có phạm vi trong hàm hoặc khối lệnh",
    "hàm tĩnh": "hàm chỉ có thể được gọi từ trong lớp",
    "hàm ảo": "hàm có thể được ghi đè trong lớp con",
    "hàm thuần túy ảo": "hàm ảo không có cài đặt trong lớp cơ sở",
    "đối tượng tĩnh": "đối tượng duy nhất của lớp có phạm vi toàn bộ chương trình",
    "hàm bạn": "hàm có quyền truy cập vào các thành viên riêng của lớp",
    "lớp kế thừa": "lớp kế thừa thuộc tính và phương thức từ lớp cơ sở",
    "kế thừa công khai": "kế thừa mà lớp con giữ nguyên mức độ truy cập của lớp cơ sở",
    "kế thừa riêng tư": "kế thừa mà lớp con giữ các thành viên của lớp cơ sở là riêng tư",
    "kế thừa bảo vệ": "kế thừa mà các thành viên của lớp cơ sở trở thành bảo vệ trong lớp con",
    "hàm gọi lại": "hàm được truyền vào như một đối số và gọi từ bên trong hàm khác",
    "hàm lambda": "hàm ẩn danh định nghĩa ngay trong biểu thức",
    "tinh chỉnh mẫu": "cung cấp phiên bản cụ thể của mẫu hàm hoặc lớp",
    "biến động": "biến được cấp phát bộ nhớ tại thời gian chạy",
    "hàm động": "hàm gọi thông qua con trỏ hàm",
    "mảng động": "mảng được cấp phát bộ nhớ tại thời gian chạy",
    "danh sách liên kết": "cấu trúc dữ liệu nơi các phần tử được liên kết với nhau qua con trỏ",
    "danh sách đôi": "danh sách liên kết với các con trỏ trước và sau mỗi phần tử",
    "ngăn xếp": "cấu trúc dữ liệu theo kiểu LIFO (Last In, First Out)",
    "hàng đợi": "cấu trúc dữ liệu theo kiểu FIFO (First In, First Out)",
    "cây nhị phân": "cấu trúc dữ liệu với mỗi nút có tối đa hai con",
    "cây AVL": "cây nhị phân tự cân bằng",
    "cây đỏ-đen": "cây nhị phân cân bằng với các quy tắc về màu sắc",
    "thuật toán sắp xếp nhanh": "thuật toán sắp xếp sử dụng phân chia và chinh phục",
    "thuật toán sắp xếp chọn": "thuật toán sắp xếp bằng cách chọn phần tử nhỏ nhất",
    "thuật toán sắp xếp chèn": "thuật toán sắp xếp bằng cách chèn phần tử vào vị trí đúng",
    "thuật toán sắp xếp nổi bọt": "thuật toán sắp xếp bằng cách so sánh và hoán đổi liên tiếp",
    "hàm hàm": "hàm trả về một hàm khác",
    "hàm trừu tượng": "hàm không có định nghĩa trong lớp cơ sở",
    "lớp lớp con": "lớp kế thừa từ lớp cơ sở",
    "lớp cơ sở": "lớp bị kế thừa bởi lớp con",
    "tính đa hình": "khả năng gọi hàm khác nhau tùy thuộc vào kiểu đối tượng",
    "khái niệm đối tượng": "các thực thể của lớp có trạng thái và hành vi",
    "hàm thành viên": "hàm thuộc về lớp và hoạt động trên các đối tượng của lớp đó",
    "hàm phi thành viên": "hàm không thuộc về lớp, hoạt động trên các đối tượng của lớp thông qua đối số",
    "hàm tạo": "hàm được gọi khi tạo đối tượng",
    "hàm hủy": "hàm được gọi khi đối tượng bị hủy",
    "hàm sao chép": "hàm tạo bản sao của đối tượng",
    "hàm di chuyển": "hàm chuyển quyền sở hữu tài nguyên từ một đối tượng sang đối tượng khác",
    "tập lệnh tiền xử lý": "lệnh thực thi trước khi biên dịch mã nguồn",
    "biểu thức điều kiện": "biểu thức đánh giá điều kiện trong khối lệnh if",
    "toán tử ba ngôi": "toán tử rút gọn cho câu lệnh if-else",
    "toán tử so sánh": "toán tử kiểm tra các mối quan hệ giữa hai giá trị",
    "hàm thao tác chuỗi": "hàm thực hiện các thao tác trên chuỗi ký tự",
    "hàm toán học": "hàm thực hiện các phép toán số học",
    "hàm thư viện chuẩn": "hàm có sẵn trong thư viện chuẩn C++",
    "thuật toán tìm kiếm nhị phân": "thuật toán tìm kiếm trong mảng đã sắp xếp",
    "cấu trúc dữ liệu": "cách tổ chức và lưu trữ dữ liệu",
    "giao diện người dùng": "phần tương tác của phần mềm với người dùng",
    "thư viện bên ngoài": "thư viện không thuộc thư viện chuẩn",
    "thư viện chuẩn": "thư viện đi kèm với ngôn ngữ lập trình",
    "kiểu dữ liệu nguyên thủy": "các kiểu dữ liệu cơ bản như int, char, float",
    "kiểu dữ liệu phức hợp": "các kiểu dữ liệu bao gồm nhiều phần tử như mảng, danh sách",
    "chỉ thị tiền xử lý": "câu lệnh điều khiển tiền xử lý mã nguồn",
    "state pattern": "mẫu trạng thái",
    "khai báo biến": "int a;",
    "khai báo hằng số": "const int MAX = 100;",
    "khai báo hàm": "void myFunction();",
    "khai báo hàm với tham số": "void myFunction(int a, float b);",
    "khai báo hàm trả về giá trị": "int add(int a, int b);",
    "khai báo lớp": "class MyClass { public: int myVar; };",
    "khai báo lớp với phương thức": "class MyClass { public: void myMethod(); };",
    "khai báo lớp với thuộc tính và phương thức": "class MyClass { private: int myVar; public: void myMethod(); };",
    "khai báo hàm trong lớp": "class MyClass { public: void myMethod() { // code } };",
    "khai báo lớp kế thừa": "class DerivedClass : public BaseClass {};",
    "khai báo constructor": "MyClass::MyClass() { // code }",
    "khai báo destructor": "MyClass::~MyClass() { // code }",
    "khai báo hàm ảo": "virtual void myVirtualFunction();",
    "khai báo hàm ảo thuần túy": "virtual void myPureVirtualFunction() = 0;",
    "khai báo biến tĩnh": "static int myStaticVar;",
    "khai báo biến toàn cục": "int globalVar;",
    "khai báo biến cục bộ": "void myFunction() { int localVar; }",
    "khai báo hằng số tĩnh": "static const int MAX = 100;",
    "khai báo con trỏ": "int* ptr;",
    "khai báo tham chiếu": "int& ref = x;",
    "khai báo mảng": "int arr[10];",
    "khai báo mảng động": "int* arr = new int[10];",
    "khai báo mảng đa chiều": "int arr[3][4];",
    "khai báo chuỗi ký tự": "char str[] = \"Hello\";",
    "khai báo chuỗi ký tự động": "std::string str = \"Hello\";",
    "khai báo cấu trúc": "struct MyStruct { int a; float b; };",
    "khai báo enum": "enum Color { RED, GREEN, BLUE };",
    "khai báo union": "union MyUnion { int i; float f; };",
    "khai báo template hàm": "template <typename T> void myFunction(T a) { // code }",
    "khai báo template lớp": "template <typename T> class MyClass { T data; };",
    "khai báo lambda": "auto lambda = [] (int a, int b) { return a + b; };",
    "khai báo lớp giao diện": "class IInterface { virtual void doSomething() = 0; };",
    "khai báo lớp trừu tượng": "class AbstractClass { virtual void doSomething() = 0; };",
    "khai báo lớp bạn": "class FriendClass { friend void myFriendFunction(); };",
    "khai báo lớp con": "class DerivedClass : public BaseClass { /* code */ };",
    "khai báo phép toán nạp chồng": "int operator+(const MyClass& other);",
    "khai báo phép toán nạp chồng so sánh": "bool operator==(const MyClass& other) const;",
    "khai báo hàm template đặc biệt": "template <> void myFunction<int>(int a) { // code }",
    "khai báo hàm động": "typedef void (*FunctionPtr)(int);",
    "khai báo đối tượng tĩnh": "static MyClass obj;",
    "khai báo biến nguyên tử": "std::atomic<int> atomicVar;",
    "khai báo mutex": "std::mutex mtx;",
    "khai báo biến điều kiện": "std::condition_variable cv;",
    "khai báo lớp cây nhị phân": "class BinaryTree { /* code */ };",
    "khai báo lớp danh sách liên kết": "class LinkedList { /* code */ };",
    "khai báo lớp ngăn xếp": "class Stack { /* code */ };",
    "khai báo lớp hàng đợi": "class Queue { /* code */ };",
    "khai báo kiểu enum class": "enum class Color { RED, GREEN, BLUE };",
    "khai báo hàm thành viên lớp template": "template <typename T> class MyClass { void myMethod(T a); };",
    "khai báo phương thức lớp template": "template <typename T> void MyClass<T>::myMethod(T a) { /* code */ }",
    "khai báo hàm phi thành viên với tham số lớp template": "template <typename T> void myFunction(MyClass<T> obj);",
    "khai báo hàm phi thành viên với tham số lớp": "void myFunction(MyClass obj);",
    "khai báo kiểu bí danh": "using MyAlias = int;",
    "khai báo macro": "#define PI 3.14",
    "khai báo chỉ thị tiền xử lý include": "#include <iostream>",
    "khai báo chỉ thị tiền xử lý define": "#define MAX 100",
    "khai báo chỉ thị tiền xử lý ifndef": "#ifndef MYHEADER_H",
    "khai báo chỉ thị tiền xử lý endif": "#endif",
    "khai báo chỉ thị tiền xử lý pragma": "#pragma once",
    "khai báo kiểu dữ liệu tự định nghĩa": "typedef unsigned long ulong;",
    "khai báo kiểu dữ liệu bằng enum": "enum class Status { OK, ERROR };",
    "khai báo kiểu dữ liệu bằng struct": "struct Point { int x; int y; };",
    "khai báo kiểu dữ liệu bằng union": "union Data { int i; float f; };",
    "khai báo kiểu dữ liệu bằng class": "class Person { std::string name; int age; };",
    "khai báo template hàm với nhiều tham số": "template <typename T1, typename T2> void func(T1 a, T2 b) { /* code */ }",
    "khai báo template lớp với nhiều tham số": "template <typename T1, typename T2> class MyClass { T1 data1; T2 data2; };",
    "khai báo biến tĩnh trong lớp": "class MyClass { public: static int count; };",
    "khai báo phương thức tĩnh trong lớp": "class MyClass { public: static void staticMethod(); };",
    "khai báo phương thức tĩnh của lớp": "void MyClass::staticMethod() { /* code */ }",
    "khai báo hàm chuyển đổi kiểu dữ liệu": "explicit operator int() const { return value; }",
    "khai báo toán tử nạp chồng cho phép cộng": "MyClass operator+(const MyClass& other) const;",
    "khai báo toán tử nạp chồng cho phép trừ": "MyClass operator-(const MyClass& other) const;",
    "khai báo toán tử nạp chồng cho phép so sánh": "bool operator==(const MyClass& other) const;",
    "khai báo toán tử nạp chồng cho phép in ra": "friend std::ostream& operator<<(std::ostream& os, const MyClass& obj);",
    "khai báo toán tử nạp chồng cho phép gán": "MyClass& operator=(const MyClass& other);",
    "khai báo toán tử nạp chồng cho phép truy cập phần tử": "int& operator[](size_t index);",
    "khai báo hàm ảo trong lớp cơ sở": "virtual void draw();",
    "khai báo hàm ảo được ghi đè trong lớp con": "void draw() override { /* code */ }",
    "khai báo lớp trừu tượng với hàm ảo thuần túy": "class AbstractBase { virtual void pureVirtual() = 0; };",
    "khai báo hàm bạn trong lớp": "class MyClass { friend void show(const MyClass& obj); };",
    "khai báo lớp giao diện với các phương thức ảo thuần túy": "class Interface { virtual void method() = 0; };",
    "khai báo lớp con của lớp giao diện": "class Derived : public Interface { void method() override; };",
    "khai báo hàm động với đối số là con trỏ hàm": "void callFunction(void (*func)(int), int value);",
    "khai báo biến toàn cục với giá trị khởi tạo": "int globalVar = 10;",
    "khai báo biến toàn cục không có giá trị khởi tạo": "extern int globalVar;",
    "khai báo cấu trúc dữ liệu danh sách liên kết đơn": "struct Node { int data; Node* next; };",
    "khai báo cấu trúc dữ liệu danh sách liên kết đôi": "struct Node { int data; Node* next; Node* prev; };",
    "khai báo cấu trúc dữ liệu ngăn xếp": "class Stack { private: std::vector<int> elements; public: void push(int value); int pop(); };",
    "khai báo cấu trúc dữ liệu hàng đợi": "class Queue { private: std::deque<int> elements; public: void enqueue(int value); int dequeue(); };",
    "khai báo cấu trúc dữ liệu cây nhị phân": "class BinaryTree { private: struct Node { int data; Node* left; Node* right; }; Node* root; public: void insert(int value); };",
    "khai báo thuật toán tìm kiếm tuần tự": "int sequentialSearch(const std::vector<int>& arr, int target);",
    "khai báo thuật toán sắp xếp chèn với mảng": "void insertionSort(int arr[], int n);",
    "khai báo thuật toán sắp xếp chọn với mảng": "void selectionSort(int arr[], int n);",
    "khai báo thuật toán sắp xếp nổi bọt với mảng": "void bubbleSort(int arr[], int n);",
    "khai báo hàm tạo lớp với tham số mặc định": "MyClass(int a = 0, int b = 0);",
    "khai báo hàm hủy lớp với tham số mặc định": "~MyClass() { /* code */ }",
    "khai báo phương thức với tham số mặc định": "void printMessage(std::string message = \"Hello\");",
    "khai báo hàm với tham số biến số lượng": "void printNumbers(int count, ...);",
    "khai báo sử dụng chỉ thị tiền xử lý include": "#include <vector>",
    "khai báo chỉ thị tiền xử lý define để xác định hằng số": "#define PI 3.14159",
    "khai báo chỉ thị tiền xử lý include với thư viện nội bộ": "#include \"myheader.h\"",
    "khai báo chỉ thị tiền xử lý pragma để ngăn lặp bao gồm": "#pragma once",
    "khai báo biến tham chiếu const": "const int& ref = x;",
    "khai báo biến con trỏ const": "const int* ptr = &x;",
    "khai báo biến const con trỏ": "int* const ptr = &x;",
    "khai báo biến const con trỏ const": "const int* const ptr = &x;",
    "khai báo cấu trúc dữ liệu cây nhị phân tìm kiếm": "class BinarySearchTree { private: struct Node { int key; Node* left; Node* right; }; Node* root; public: void insert(int key); bool search(int key); };",
    "khai báo lớp với phương thức tinh chỉnh": "class MyClass { public: void doSomething() const; };",
    "khai báo phương thức tinh chỉnh trong lớp": "void MyClass::doSomething() const { /* code */ }",
    "khai báo lớp với phương thức tĩnh và biến tĩnh": "class MyClass { public: static void staticMethod(); static int staticVar; };",
    "khai báo hàm template với biến kiểu": "template <typename T> void printType() { std::cout << typeid(T).name() << std::endl; }",
    "khai báo lớp template với hàm tinh chỉnh": "template <typename T> class MyClass { public: void show() const { std::cout << typeid(T).name() << std::endl; } };",
    "khai báo phương thức template trong lớp": "template <typename T> void MyClass<T>::show() const { std::cout << typeid(T).name() << std::endl; }",
    "khai báo cấu trúc dữ liệu đống (heap)": "class Heap { private: std::vector<int> elements; public: void insert(int value); int extractMax(); };",
    "khai báo cấu trúc dữ liệu đồ thị": "class Graph { private: std::vector<std::vector<int>> adjList; public: void addEdge(int u, int v); };",
    "khai báo lớp với toán tử chuyển đổi kiểu dữ liệu": "class MyClass { public: operator int() const { return value; } private: int value; };",
    "khai báo lớp với toán tử so sánh": "class MyClass { public: bool operator<(const MyClass& other) const { return value < other.value; } private: int value; };",
    "khai báo lớp với toán tử cộng": "class MyClass { public: MyClass operator+(const MyClass& other) const { return MyClass(value + other.value); } private: int value; };",
    "khai báo lớp với toán tử gán": "class MyClass { public: MyClass& operator=(const MyClass& other) { value = other.value; return *this; } private: int value; };",
    "khai báo lớp với toán tử gọi hàm": "class MyClass { public: int operator()(int x) { return value + x; } private: int value; };",
    "khai báo lớp với toán tử chỉ số": "class MyClass { public: int& operator[](size_t index) { return data[index]; } private: std::vector<int> data; };",
    "khai báo hàm ảo thuần túy trong lớp cơ sở": "class Base { virtual void pureVirtualMethod() = 0; };",
    "khai báo lớp con kế thừa và ghi đè hàm ảo": "class Derived : public Base { public: void pureVirtualMethod() override { /* code */ } };",
    "khai báo lớp có hàm friend": "class MyClass { friend void show(const MyClass& obj); private: int data; };",
    "khai báo hàm friend ngoài lớp": "void show(const MyClass& obj) { std::cout << obj.data << std::endl; }",
    "khai báo lớp với kiểu dữ liệu bí danh (alias)": "class MyClass { using IntPtr = int*; IntPtr ptr; };",
    "khai báo cấu trúc dữ liệu danh sách liên kết vòng": "class CircularLinkedList { private: struct Node { int data; Node* next; }; Node* head; public: void insert(int value); };",
    "khai báo cấu trúc dữ liệu hàng đợi ưu tiên": "class PriorityQueue { private: std::vector<int> heap; public: void insert(int value); int extractMax(); };",
    "khai báo cấu trúc dữ liệu ngăn xếp với liên kết": "class Stack { private: struct Node { int data; Node* next; }; Node* top; public: void push(int value); int pop(); };",
    "khai báo lớp với toán tử nạp chồng cho phép so sánh khác nhau": "class MyClass { public: bool operator!=(const MyClass& other) const { return value != other.value; } private: int value; };",
    "khai báo lớp với toán tử nạp chồng cho phép lấy giá trị": "class MyClass { public: int getValue() const { return value; } private: int value; };",
    "khai báo lớp với toán tử nạp chồng cho phép cộng": "class MyClass { public: MyClass operator+(const MyClass& other) const { return MyClass(value + other.value); } private: int value; };",
    "khai báo lớp với hàm thành viên sử dụng template": "template <typename T> class MyClass { public: T add(T a, T b) { return a + b; } };",
    "khai báo lớp với phương thức trả về con trỏ": "class MyClass { public: int* getPointer(); private: int value; };",
    "khai báo lớp với phương thức trả về tham chiếu": "class MyClass { public: int& getReference(); private: int value; };",
    "khai báo lớp với phương thức trả về giá trị tham số": "class MyClass { public: int getValue() const { return value; } private: int value; };",
    "khai báo lớp với phương thức trả về kiểu dữ liệu tĩnh": "class MyClass { public: static int getStaticValue(); private: static int staticValue; };",
    "khai báo lớp với phương thức trả về kiểu dữ liệu tĩnh": "int MyClass::getStaticValue() { return staticValue; }",
    "khai báo lớp với hàm bạn và hàm thành viên bạn": "class MyClass { public: friend void showValue(const MyClass& obj); private: int value; }; void showValue(const MyClass& obj) { std::cout << obj.value << std::endl; }",
    "khai báo lớp với phương thức khởi tạo tham số": "class MyClass { public: MyClass(int x) : value(x) {} private: int value; };",
    "khai báo lớp với phương thức khởi tạo mặc định": "class MyClass { public: MyClass() : value(0) {} private: int value; };",
    "khai báo lớp với phương thức khởi tạo sao chép": "class MyClass { public: MyClass(const MyClass& other) : value(other.value) {} private: int value; };",
    "khai báo lớp với phương thức di chuyển": "class MyClass { public: MyClass(MyClass&& other) noexcept : value(other.value) { other.value = 0; } private: int value; };",
    "khai báo lớp với toán tử gán sao chép": "class MyClass { public: MyClass& operator=(const MyClass& other) { if (this != &other) { value = other.value; } return *this; } private: int value; };",
    "khai báo lớp với toán tử gán di chuyển": "class MyClass { public: MyClass& operator=(MyClass&& other) noexcept { if (this != &other) { value = other.value; other.value = 0; } return *this; } private: int value; };",
    "khai báo lớp với phương thức hủy": "class MyClass { public: ~MyClass() { /* cleanup code */ } private: int value; };",
    "khai báo lớp với hàm thành viên tĩnh": "class MyClass { public: static void staticMethod() { /* code */ } private: static int staticVar; };",
    "khai báo lớp với phương thức nhận tham số biến số": "class MyClass { public: void printValues(int count, ...) { va_list args; va_start(args, count); for (int i = 0; i < count; ++i) { std::cout << va_arg(args, int) << std::endl; } va_end(args); } };",
    "khai báo lớp với hàm thành viên có giá trị mặc định": "class MyClass { public: void print(int value = 10) { std::cout << value << std::endl; } };",
    "khai báo lớp với toán tử nạp chồng cho phép cộng chuỗi": "class MyString { public: MyString operator+(const MyString& other) const { return MyString(data + other.data); } private: std::string data; };",
    "khai báo lớp với toán tử nạp chồng cho phép so sánh bằng chuỗi": "class MyString { public: bool operator==(const MyString& other) const { return data == other.data; } private: std::string data; };",
    "khai báo lớp với phương thức truy cập dữ liệu kiểu enum": "enum class Color { Red, Green, Blue }; class MyClass { public: void setColor(Color c) { color = c; } Color getColor() const { return color; } private: Color color; };",
    "khai báo lớp với phương thức trả về giá trị kiểu enum": "enum class Color { Red, Green, Blue }; class MyClass { public: Color getColor() const { return color; } private: Color color; };",
    "khai báo lớp với phương thức thay đổi giá trị enum": "enum class Color { Red, Green, Blue }; class MyClass { public: void setColor(Color c) { color = c; } private: Color color; };",
    "khai báo lớp với phương thức nhận tham số kiểu enum": "enum class Color { Red, Green, Blue }; class MyClass { public: void setColor(Color c) { color = c; } private: Color color; };",
    "khai báo lớp với phương thức tính toán tổng của các số trong vector": "class MyClass { public: int sum(const std::vector<int>& numbers) const { int total = 0; for (int num : numbers) { total += num; } return total; } };",
    "khai báo lớp với phương thức tính toán tích của các số trong vector": "class MyClass { public: int product(const std::vector<int>& numbers) const { int total = 1; for (int num : numbers) { total *= num; } return total; } };",
    "khai báo lớp với phương thức kiểm tra số nguyên tố": "class MathUtils { public: bool isPrime(int number) const { if (number <= 1) return false; for (int i = 2; i <= sqrt(number); ++i) { if (number % i == 0) return false; } return true; } };",
    "khai báo lớp với phương thức kiểm tra số hoàn hảo": "class MathUtils { public: bool isPerfect(int number) const { int sum = 0; for (int i = 1; i <= number / 2; ++i) { if (number % i == 0) sum += i; } return sum == number; } };",
    "khai báo lớp với phương thức kiểm tra số Armstrong": "class MathUtils { public: bool isArmstrong(int number) const { int sum = 0, temp = number, digits = 0; while (temp != 0) { ++digits; temp /= 10; } temp = number; while (temp != 0) { int digit = temp % 10; sum += pow(digit, digits); temp /= 10; } return sum == number; } };",
    "khai báo lớp với phương thức kiểm tra số Fibonacci": "class MathUtils { public: bool isFibonacci(int number) const { int a = 0, b = 1; while (b < number) { int temp = a; a = b; b = temp + b; } return b == number; } };",
    "khai báo lớp với phương thức sắp xếp mảng sử dụng thuật toán sắp xếp nổi bọt": "class SortUtils { public: void bubbleSort(std::vector<int>& arr) const { for (size_t i = 0; i < arr.size() - 1; ++i) { for (size_t j = 0; j < arr.size() - i - 1; ++j) { if (arr[j] > arr[j + 1]) std::swap(arr[j], arr[j + 1]); } } } };",
    "khai báo lớp với phương thức sắp xếp mảng sử dụng thuật toán sắp xếp chọn": "class SortUtils { public: void selectionSort(std::vector<int>& arr) const { for (size_t i = 0; i < arr.size() - 1; ++i) { size_t minIdx = i; for (size_t j = i + 1; j < arr.size(); ++j) { if (arr[j] < arr[minIdx]) minIdx = j; } std::swap(arr[i], arr[minIdx]); } } };",
    "khai báo lớp với phương thức sắp xếp mảng sử dụng thuật toán sắp xếp chèn": "class SortUtils { public: void insertionSort(std::vector<int>& arr) const { for (size_t i = 1; i < arr.size(); ++i) { int key = arr[i]; size_t j = i; while (j > 0 && arr[j - 1] > key) { arr[j] = arr[j - 1]; --j; } arr[j] = key; } } };",
    "khai báo lớp với phương thức tìm kiếm nhị phân trong mảng đã sắp xếp": "class SearchUtils { public: int binarySearch(const std::vector<int>& arr, int target) const { int left = 0, right = arr.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; } };",
    "khai báo lớp với phương thức tìm kiếm tuần tự trong mảng": "class SearchUtils { public: int linearSearch(const std::vector<int>& arr, int target) const { for (size_t i = 0; i < arr.size(); ++i) { if (arr[i] == target) return i; } return -1; } };",
    "khai báo lớp với phương thức tính số lượng chữ cái trong chuỗi": "class StringUtils { public: int countLetters(const std::string& str) const { int count = 0; for (char c : str) { if (isalpha(c)) ++count; } return count; } };",
    "khai báo biến và kiểu dữ liệu cơ bản": "int a = 10; float b = 5.5; char c = 'A'; bool d = true;",
    "hàm tính tổng hai số": "int add(int x, int y) { return x + y; }",
    "hàm tính hiệu hai số": "int subtract(int x, int y) { return x - y; }",
    "hàm tính tích hai số": "int multiply(int x, int y) { return x * y; }",
    "hàm tính thương hai số": "float divide(int x, int y) { return y != 0 ? static_cast<float>(x) / y : 0; }",
    "sử dụng vòng lặp for để in các số từ 1 đến 10": "for (int i = 1; i <= 10; ++i) { std::cout << i << ' '; }",
    "sử dụng vòng lặp while để in các số từ 1 đến 10": "int i = 1; while (i <= 10) { std::cout << i << ' '; ++i; }",
    "sử dụng vòng lặp do-while để in các số từ 1 đến 10": "int i = 1; do { std::cout << i << ' '; ++i; } while (i <= 10);",
    "sử dụng câu lệnh if-else để kiểm tra số chẵn lẻ": "if (number % 2 == 0) { std::cout << 'Even'; } else { std::cout << 'Odd'; }",
    "sử dụng câu lệnh switch để kiểm tra ngày trong tuần": "switch (day) { case 1: std::cout << 'Monday'; break; case 2: std::cout << 'Tuesday'; break; // cases for other days break; default: std::cout << 'Invalid day'; }",
    "tạo một mảng và in các giá trị": "int arr[] = {1, 2, 3, 4, 5}; for (int i = 0; i < 5; ++i) { std::cout << arr[i] << ' '; }",
    "sử dụng hàm để tính giai thừa của một số": "int factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); }",
    "tìm số lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { int max = arr[0]; for (int num : arr) { if (num > max) max = num; } return max; }",
    "tính tổng các số trong mảng": "int sumArray(const std::vector<int>& arr) { int sum = 0; for (int num : arr) { sum += num; } return sum; }",
    "sắp xếp mảng bằng thuật toán sắp xếp chọn": "void selectionSort(std::vector<int>& arr) { for (size_t i = 0; i < arr.size() - 1; ++i) { size_t minIdx = i; for (size_t j = i + 1; j < arr.size(); ++j) { if (arr[j] < arr[minIdx]) minIdx = j; } std::swap(arr[i], arr[minIdx]); } }",
    "sắp xếp mảng bằng thuật toán sắp xếp nổi bọt": "void bubbleSort(std::vector<int>& arr) { for (size_t i = 0; i < arr.size() - 1; ++i) { for (size_t j = 0; j < arr.size() - i - 1; ++j) { if (arr[j] > arr[j + 1]) std::swap(arr[j], arr[j + 1]); } } }",
    "sắp xếp mảng bằng thuật toán sắp xếp chèn": "void insertionSort(std::vector<int>& arr) { for (size_t i = 1; i < arr.size(); ++i) { int key = arr[i]; size_t j = i; while (j > 0 && arr[j - 1] > key) { arr[j] = arr[j - 1]; --j; } arr[j] = key; } }",
    "tìm số nguyên tố trong khoảng từ 1 đến n": "void printPrimes(int n) { for (int num = 2; num <= n; ++num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) std::cout << num << ' '; } }",
    "tính tổng các chữ số của một số nguyên": "int sumDigits(int number) { int sum = 0; while (number > 0) { sum += number % 10; number /= 10; } return sum; }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int number) { int root = static_cast<int>(sqrt(number)); return root * root == number; }",
    "chuyển đổi số nguyên thành chuỗi": "std::string intToString(int number) { return std::to_string(number); }",
    "chuyển đổi chuỗi thành số nguyên": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "tạo lớp cơ bản với các thuộc tính và phương thức": "class Person { public: Person(std::string name, int age) : name(name), age(age) {} void introduce() const { std::cout << 'Name: ' << name << ', Age: ' << age; } private: std::string name; int age; };",
    "tạo lớp cơ bản với hàm khởi tạo mặc định": "class Rectangle { public: Rectangle() : width(0), height(0) {} Rectangle(int w, int h) : width(w), height(h) {} int area() const { return width * height; } private: int width, height; };",
    "tìm số Fibonacci thứ n": "int fibonacci(int n) { if (n <= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }",
    "tìm số Fibonacci thứ n (phiên bản động)": "int fibonacci(int n) { if (n <= 1) return n; std::vector<int> fib(n + 1); fib[0] = 0; fib[1] = 1; for (int i = 2; i <= n; ++i) { fib[i] = fib[i - 1] + fib[i - 2]; } return fib[n]; }",
    "tìm ước số chung lớn nhất (UCLN) của hai số bằng thuật toán Euclid": "int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; }",
    "tìm bội số chung nhỏ nhất (BCNN) của hai số": "int lcm(int a, int b) { return a * b / gcd(a, b); }",
    "tìm số nguyên tố lớn nhất nhỏ hơn hoặc bằng n": "int largestPrime(int n) { for (int num = n; num >= 2; --num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) return num; } return -1; }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimes(int n) { int sum = 0; for (int num = 2; num < n; ++num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) sum += num; } return sum; }",
    "thuật toán tìm kiếm nhị phân": "int binarySearch(const std::vector<int>& arr, int target) { int left = 0, right = arr.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",
    "sắp xếp mảng bằng thuật toán sắp xếp hòa nhập (Merge Sort)": "void merge(std::vector<int>& arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; std::vector<int> L(n1), R(n2); for (int i = 0; i < n1; ++i) L[i] = arr[left + i]; for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j]; int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; } void mergeSort(std::vector<int>& arr, int left, int right) { if (left < right) { int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } }",
    "sắp xếp mảng bằng thuật toán sắp xếp nhanh (Quick Sort)": "int partition(std::vector<int>& arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; ++j) { if (arr[j] <= pivot) std::swap(arr[++i], arr[j]); } std::swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(std::vector<int>& arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } }",
    "tính giá trị trung bình của mảng": "double average(const std::vector<int>& arr) { int sum = 0; for (int num : arr) sum += num; return static_cast<double>(sum) / arr.size(); }",
    "tính phương sai của mảng": "double variance(const std::vector<int>& arr) { double avg = average(arr); double sum = 0; for (int num : arr) { double diff = num - avg; sum += diff * diff; } return sum / arr.size(); }",
    "tìm kiếm tuyến tính trong mảng": "int linearSearch(const std::vector<int>& arr, int target) { for (size_t i = 0; i < arr.size(); ++i) { if (arr[i] == target) return i; } return -1; }",
    "kiểm tra chuỗi có phải là palindrome không": "bool isPalindrome(const std::string& str) { int left = 0, right = str.size() - 1; while (left < right) { if (str[left++] != str[right--]) return false; } return true; }",
    "tìm số lớn thứ hai trong mảng": "int secondLargest(const std::vector<int>& arr) { int largest = INT_MIN, second = INT_MIN; for (int num : arr) { if (num > largest) { second = largest; largest = num; } else if (num > second && num < largest) { second = num; } } return second; }",
    "tính số lượng số nguyên tố trong mảng": "int countPrimes(const std::vector<int>& arr) { int count = 0; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) ++count; } return count; }",
    "tìm số Fibonacci thứ n": "int fibonacci(int n) { if (n <= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }",
    "tìm số Fibonacci thứ n (phiên bản động)": "int fibonacci(int n) { if (n <= 1) return n; std::vector<int> fib(n + 1); fib[0] = 0; fib[1] = 1; for (int i = 2; i <= n; ++i) { fib[i] = fib[i - 1] + fib[i - 2]; } return fib[n]; }",
    "tìm ước số chung lớn nhất (UCLN) của hai số bằng thuật toán Euclid": "int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; }",
    "tìm bội số chung nhỏ nhất (BCNN) của hai số": "int lcm(int a, int b) { return a * b / gcd(a, b); }",
    "tìm số nguyên tố lớn nhất nhỏ hơn hoặc bằng n": "int largestPrime(int n) { for (int num = n; num >= 2; --num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) return num; } return -1; }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimes(int n) { int sum = 0; for (int num = 2; num < n; ++num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) sum += num; } return sum; }",
    "thuật toán tìm kiếm nhị phân": "int binarySearch(const std::vector<int>& arr, int target) { int left = 0, right = arr.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",
    "sắp xếp mảng bằng thuật toán sắp xếp hòa nhập (Merge Sort)": "void merge(std::vector<int>& arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; std::vector<int> L(n1), R(n2); for (int i = 0; i < n1; ++i) L[i] = arr[left + i]; for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j]; int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; } void mergeSort(std::vector<int>& arr, int left, int right) { if (left < right) { int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } }",
    "sắp xếp mảng bằng thuật toán sắp xếp nhanh (Quick Sort)": "int partition(std::vector<int>& arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; ++j) { if (arr[j] <= pivot) std::swap(arr[++i], arr[j]); } std::swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(std::vector<int>& arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } }",
    "tính giá trị trung bình của mảng": "double average(const std::vector<int>& arr) { int sum = 0; for (int num : arr) sum += num; return static_cast<double>(sum) / arr.size(); }",
    "tính phương sai của mảng": "double variance(const std::vector<int>& arr) { double avg = average(arr); double sum = 0; for (int num : arr) { double diff = num - avg; sum += diff * diff; } return sum / arr.size(); }",
    "tìm kiếm tuyến tính trong mảng": "int linearSearch(const std::vector<int>& arr, int target) { for (size_t i = 0; i < arr.size(); ++i) { if (arr[i] == target) return i; } return -1; }",
    "kiểm tra chuỗi có phải là palindrome không": "bool isPalindrome(const std::string& str) { int left = 0, right = str.size() - 1; while (left < right) { if (str[left++] != str[right--]) return false; } return true; }",
    "tìm số lớn thứ hai trong mảng": "int secondLargest(const std::vector<int>& arr) { int largest = INT_MIN, second = INT_MIN; for (int num : arr) { if (num > largest) { second = largest; largest = num; } else if (num > second && num < largest) { second = num; } } return second; }",
    "tính số lượng số nguyên tố trong mảng": "int countPrimes(const std::vector<int>& arr) { int count = 0; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) ++count; } return count; }",
    "kiểm tra số chẵn hay lẻ": "bool isEven(int num) { return num % 2 == 0; }",
    "tính tổng các số từ 1 đến n": "int sumToN(int n) { int sum = 0; for (int i = 1; i <= n; ++i) { sum += i; } return sum; }",
    "tính giai thừa của n": "int factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int num) { int root = static_cast<int>(sqrt(num)); return root * root == num; }",
    "in bảng cửu chương": "void printMultiplicationTable(int n) { for (int i = 1; i <= 10; ++i) { std::cout << n << \" x \" << i << \" = \" << n * i << std::endl; } }",
    "tạo mảng 2 chiều và in ra": "void print2DArray(int rows, int cols) { std::vector<std::vector<int>> arr(rows, std::vector<int>(cols)); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { arr[i][j] = i * cols + j; } } for (const auto& row : arr) { for (int elem : row) { std::cout << elem << \" \"; } std::cout << std::endl; } }",
    "chuyển đổi số từ hệ thập phân sang hệ nhị phân": "std::string toBinary(int num) { if (num == 0) return \"0\"; std::string binary; while (num > 0) { binary = std::to_string(num % 2) + binary; num /= 2; } return binary; }",
    "tìm giá trị lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { int max = arr[0]; for (int num : arr) { if (num > max) max = num; } return max; }",
    "tìm giá trị nhỏ nhất trong mảng": "int findMin(const std::vector<int>& arr) { int min = arr[0]; for (int num : arr) { if (num < min) min = num; } return min; }",
    "in số nguyên tố trong một khoảng cho trước": "void printPrimesInRange(int start, int end) { for (int num = start; num <= end; ++num) { bool isPrime = true; if (num < 2) isPrime = false; else { for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } } if (isPrime) std::cout << num << \" \"; } std::cout << std::endl; }",
    "kiểm tra một số có phải là số Armstrong không": "bool isArmstrong(int num) { int sum = 0, original = num; int digits = std::to_string(num).size(); while (num > 0) { int digit = num % 10; sum += pow(digit, digits); num /= 10; } return sum == original; }",
    "tạo và in ma trận số nguyên ngẫu nhiên": "void printRandomMatrix(int rows, int cols) { std::srand(static_cast<unsigned>(std::time(nullptr))); std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { matrix[i][j] = std::rand() % 100; } } for (const auto& row : matrix) { for (int elem : row) { std::cout << elem << \" \"; } std::cout << std::endl; } }",
    "tìm giá trị trung bình của mảng": "double average(const std::vector<int>& arr) { double sum = 0; for (int num : arr) sum += num; return sum / arr.size(); }",
    "sắp xếp mảng theo thứ tự tăng dần (Bubble Sort)": "void bubbleSort(std::vector<int>& arr) { int n = arr.size(); for (int i = 0; i < n - 1; ++i) { for (int j = 0; j < n - i - 1; ++j) { if (arr[j] > arr[j + 1]) std::swap(arr[j], arr[j + 1]); } } }",
    "tìm số lặp lại nhiều nhất trong mảng": "int mostFrequent(const std::vector<int>& arr) { std::unordered_map<int, int> freq; int maxCount = 0, mostFrequent; for (int num : arr) { freq[num]++; if (freq[num] > maxCount) { maxCount = freq[num]; mostFrequent = num; } } return mostFrequent; }",
    "tính số chữ cái trong chuỗi": "int countLetters(const std::string& str) { int count = 0; for (char c : str) { if (std::isalpha(c)) ++count; } return count; }",
    "đảo ngược chuỗi": "std::string reverseString(const std::string& str) { std::string reversed; for (auto it = str.rbegin(); it != str.rend(); ++it) { reversed += *it; } return reversed; }",
    "đếm số từ trong chuỗi": "int countWords(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "tạo một danh sách liên kết đơn giản và in ra các phần tử": "struct Node { int data; Node* next; }; void printList(Node* head) { Node* temp = head; while (temp != nullptr) { std::cout << temp->data << \" \"; temp = temp->next; } std::cout << std::endl; }",
    "tính tổng các số trong mảng đa chiều": "int sum2DArray(const std::vector<std::vector<int>>& arr) { int sum = 0; for (const auto& row : arr) { for (int elem : row) { sum += elem; } } return sum; }",
    "kiểm tra một số có phải là số hoàn hảo không": "bool isPerfect(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "tạo một ma trận số nguyên và tính tổng của các đường chéo": "int diagonalSum(const std::vector<std::vector<int>>& matrix) { int primary = 0, secondary = 0; int n = matrix.size(); for (int i = 0; i < n; ++i) { primary += matrix[i][i]; secondary += matrix[i][n - i - 1]; } return primary + secondary; }",
    "tìm số âm trong mảng": "std::vector<int> findNegatives(const std::vector<int>& arr) { std::vector<int> negatives; for (int num : arr) { if (num < 0) negatives.push_back(num); } return negatives; }",
    "kiểm tra một số có phải là số hoàn hảo không": "bool isPerfectNumber(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "tạo danh sách liên kết và thêm phần tử vào cuối": "Node* append(Node* head, int data) { Node* newNode = new Node{data, nullptr}; if (!head) return newNode; Node* temp = head; while (temp->next) temp = temp->next; temp->next = newNode; return head; }",
    "tạo và in ma trận số thực ngẫu nhiên": "void printRandomFloatMatrix(int rows, int cols) { std::srand(static_cast<unsigned>(std::time(nullptr))); std::vector<std::vector<float>> matrix(rows, std::vector<float>(cols)); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { matrix[i][j] = static_cast<float>(std::rand()) / RAND_MAX * 100.0f; } } for (const auto& row : matrix) { for (float elem : row) { std::cout << elem << \" \"; } std::cout << std::endl; } }",
    "tính tích các số trong mảng": "int productOfArray(const std::vector<int>& arr) { int product = 1; for (int num : arr) { product *= num; } return product; }",
    "tìm giá trị trung bình và phương sai của mảng": "double mean(const std::vector<int>& arr) { double sum = 0; for (int num : arr) sum += num; return sum / arr.size(); } double variance(const std::vector<int>& arr) { double avg = mean(arr); double sum = 0; for (int num : arr) { double diff = num - avg; sum += diff * diff; } return sum / arr.size(); }",
    "tạo mảng 1 chiều và in các phần tử chẵn": "void printEvenNumbers(const std::vector<int>& arr) { for (int num : arr) { if (num % 2 == 0) std::cout << num << \" \"; } std::cout << std::endl; }",
    "tính số lượng số âm trong mảng": "int countNegativeNumbers(const std::vector<int>& arr) { int count = 0; for (int num : arr) { if (num < 0) ++count; } return count; }",
    "tìm số nhỏ nhất trong mảng (thay vì giá trị nhỏ nhất)": "int findSmallest(const std::vector<int>& arr) { int smallest = arr[0]; for (int num : arr) { if (num < smallest) smallest = num; } return smallest; }",
    "tính tổng các số chẵn từ 1 đến n": "int sumEven(int n) { int sum = 0; for (int i = 2; i <= n; i += 2) { sum += i; } return sum; }",
    "kiểm tra một số có phải là số chính phương không": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "đảo ngược mảng số nguyên": "void reverseArray(std::vector<int>& arr) { int left = 0, right = arr.size() - 1; while (left < right) { std::swap(arr[left++], arr[right--]); } }",
    "tạo một mảng số nguyên từ 1 đến n và in ra": "std::vector<int> createArray(int n) { std::vector<int> arr(n); for (int i = 0; i < n; ++i) arr[i] = i + 1; return arr; }",
    "tìm số âm đầu tiên trong mảng": "int firstNegative(const std::vector<int>& arr) { for (int num : arr) { if (num < 0) return num; } return 0; }",
    "tìm số dương lớn nhất trong mảng": "int largestPositive(const std::vector<int>& arr) { int largest = INT_MIN; for (int num : arr) { if (num > largest && num > 0) largest = num; } return largest; }",
    "kiểm tra một chuỗi có chứa ký tự đặc biệt không": "bool hasSpecialChar(const std::string& str) { for (char c : str) { if (!std::isalnum(c) && !std::isspace(c)) return true; } return false; }",
    "tính tổng các số lẻ từ 1 đến n": "int sumOdd(int n) { int sum = 0; for (int i = 1; i <= n; i += 2) { sum += i; } return sum; }",
    "tạo ma trận số nguyên ngẫu nhiên và in ra": "void printRandomIntMatrix(int rows, int cols) { std::srand(static_cast<unsigned>(std::time(nullptr))); std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { matrix[i][j] = std::rand() % 100; } } for (const auto& row : matrix) { for (int elem : row) { std::cout << elem << \" \"; } std::cout << std::endl; } }",
    "tìm chỉ số của phần tử lớn nhất trong mảng": "int indexOfMax(const std::vector<int>& arr) { int maxIndex = 0; for (int i = 1; i < arr.size(); ++i) { if (arr[i] > arr[maxIndex]) maxIndex = i; } return maxIndex; }",
    "tạo và in danh sách liên kết với các giá trị ngẫu nhiên": "Node* createRandomList(int length) { std::srand(static_cast<unsigned>(std::time(nullptr))); Node* head = nullptr; for (int i = 0; i < length; ++i) { head = append(head, std::rand() % 100); } return head; }",
    "tìm số nhỏ nhất trong ma trận": "int findMinInMatrix(const std::vector<std::vector<int>>& matrix) { int min = matrix[0][0]; for (const auto& row : matrix) { for (int elem : row) { if (elem < min) min = elem; } } return min; }",
    "chèn một phần tử vào mảng đã sắp xếp sao cho mảng vẫn được sắp xếp": "void insertSorted(std::vector<int>& arr, int value) { auto it = std::lower_bound(arr.begin(), arr.end(), value); arr.insert(it, value); }",
    "tạo một ma trận vuông với số 1 trên đường chéo chính và 0 ở các vị trí còn lại": "std::vector<std::vector<int>> createIdentityMatrix(int size) { std::vector<std::vector<int>> matrix(size, std::vector<int>(size, 0)); for (int i = 0; i < size; ++i) matrix[i][i] = 1; return matrix; }",
    "tìm giá trị lớn nhất và nhỏ nhất trong mảng": "std::pair<int, int> minMax(const std::vector<int>& arr) { int min = arr[0], max = arr[0]; for (int num : arr) { if (num < min) min = num; if (num > max) max = num; } return {min, max}; }",
    "kiểm tra chuỗi có phải là chuỗi con của chuỗi khác không": "bool isSubstring(const std::string& str, const std::string& sub) { return str.find(sub) != std::string::npos; }",
    "tạo một danh sách liên kết đảo ngược từ một danh sách đã cho": "Node* reverseList(Node* head) { Node* prev = nullptr; Node* curr = head; while (curr != nullptr) { Node* next = curr->next; curr->next = prev; prev = curr; curr = next; } return prev; }",
    "tính tổng các số trong ma trận theo cột": "std::vector<int> columnSums(const std::vector<std::vector<int>>& matrix) { std::vector<int> sums(matrix[0].size(), 0); for (const auto& row : matrix) { for (size_t i = 0; i < row.size(); ++i) { sums[i] += row[i]; } } return sums; }",
    "tính giai thừa của một số": "int factorial(int n) { return (n <= 1) ? 1 : n * factorial(n - 1); }",
    "tính tổng các phần tử trong mảng": "int sumArray(const std::vector<int>& arr) { int sum = 0; for (int num : arr) sum += num; return sum; }",
    "kiểm tra số nguyên tố": "bool isPrime(int num) { if (num < 2) return false; for (int i = 2; i <= sqrt(num); ++i) if (num % i == 0) return false; return true; }",
    "tạo mảng số nguyên từ 0 đến n": "std::vector<int> createRange(int n) { std::vector<int> arr(n + 1); std::iota(arr.begin(), arr.end(), 0); return arr; }",
    "hoán đổi hai biến": "void swap(int& a, int& b) { int temp = a; a = b; b = temp; }",
    "kiểm tra số chẵn": "bool isEven(int num) { return num % 2 == 0; }",
    "đếm số phần tử âm trong mảng": "int countNegatives(const std::vector<int>& arr) { int count = 0; for (int num : arr) if (num < 0) ++count; return count; }",
    "tìm giá trị lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tìm giá trị nhỏ nhất trong mảng": "int findMin(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end()); }",
    "kiểm tra số dương": "bool isPositive(int num) { return num > 0; }",
    "tính tổng các phần tử trong ma trận": "int sumMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) for (int elem : row) sum += elem; return sum; }",
    "kiểm tra chuỗi có chứa số không": "bool hasDigit(const std::string& str) { return std::any_of(str.begin(), str.end(), ::isdigit); }",
    "tạo ma trận vuông với giá trị nhất định": "std::vector<std::vector<int>> createMatrix(int size, int value) { return std::vector<std::vector<int>>(size, std::vector<int>(size, value)); }",
    "tìm chỉ số của phần tử đầu tiên xuất hiện trong mảng": "int findFirstIndex(const std::vector<int>& arr, int value) { auto it = std::find(arr.begin(), arr.end(), value); return (it != arr.end()) ? std::distance(arr.begin(), it) : -1; }",
    "kiểm tra số âm": "bool isNegative(int num) { return num < 0; }",
    "tính số lượng ký tự trong chuỗi": "int countChars(const std::string& str) { return str.length(); }",
    "tạo chuỗi từ một ký tự lặp lại": "std::string createString(char ch, int n) { return std::string(n, ch); }",
    "chuyển đổi chuỗi thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "chuyển đổi chuỗi thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "xóa khoảng trắng đầu và cuối chuỗi": "std::string trim(const std::string& str) { auto start = str.find_first_not_of(' '); auto end = str.find_last_not_of(' '); return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1); }",
    "tính tổng các số trong dãy số từ 1 đến n": "int sumSequence(int n) { return n * (n + 1) / 2; }",
    "kiểm tra chuỗi có chứa ký tự đặc biệt": "bool hasSpecialChar(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char ch) { return !std::isalnum(ch) && !std::isspace(ch); }); }",
    "hoán đổi hai số nếu cần thiết": "void conditionalSwap(int& a, int& b) { if (a > b) std::swap(a, b); }",
    "tính trung bình cộng của các phần tử trong ma trận": "double averageMatrix(const std::vector<std::vector<int>>& matrix) { int total = 0, count = 0; for (const auto& row : matrix) { total += std::accumulate(row.begin(), row.end(), 0); count += row.size(); } return static_cast<double>(total) / count; }",
    "tạo mảng số nguyên từ n đến 1": "std::vector<int> createReverseRange(int n) { std::vector<int> arr(n); std::iota(arr.rbegin(), arr.rend(), 1); return arr; }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "xóa tất cả các phần tử bằng giá trị nhất định": "std::vector<int> removeAll(std::vector<int>& arr, int value) { arr.erase(std::remove(arr.begin(), arr.end(), value), arr.end()); return arr; }",
    "tính số lượng ký tự trong chuỗi không phải là chữ số": "int countNonDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), [](char ch) { return !std::isdigit(ch); }); }",
    "tìm số nhỏ nhất trong danh sách số nguyên": "int findMinInList(const std::list<int>& lst) { return *std::min_element(lst.begin(), lst.end()); }",
    "tính giai thừa của số n": "int factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); }",
    "tính số lượng số nguyên tố từ 1 đến n": "int countPrimesUpTo(int n) { int count = 0; for (int i = 2; i <= n; ++i) { bool isPrime = true; for (int j = 2; j <= std::sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) ++count; } return count; }",
    "tìm số lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tính tổng các phần tử trong ma trận": "int sumMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); } return sum; }",
    "kiểm tra số có phải là số hoàn hảo": "bool isPerfectNumber(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "hoán đổi hai số mà không dùng biến tạm": "void swapWithoutTemp(int& a, int& b) { a = a + b; b = a - b; a = a - b; }",
    "kiểm tra chuỗi có phải là anagram của chuỗi khác": "bool isAnagram(const std::string& str1, const std::string& str2) { if (str1.length() != str2.length()) return false; std::string sorted1 = str1; std::string sorted2 = str2; std::sort(sorted1.begin(), sorted1.end()); std::sort(sorted2.begin(), sorted2.end()); return sorted1 == sorted2; }",
    "tìm chỉ số của phần tử đầu tiên trong mảng lớn hơn giá trị cho trước": "int findFirstGreater(const std::vector<int>& arr, int value) { auto it = std::find_if(arr.begin(), arr.end(), [value](int x) { return x > value; }); return it != arr.end() ? std::distance(arr.begin(), it) : -1; }",
    "tạo ma trận số nguyên với giá trị mặc định": "std::vector<std::vector<int>> createMatrix(int rows, int cols, int defaultValue) { return std::vector<std::vector<int>>(rows, std::vector<int>(cols, defaultValue)); }",
    "tính số lượng phần tử chẵn trong mảng": "int countEvens(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int x) { return x % 2 == 0; }); }",
    "sắp xếp mảng theo thứ tự giảm dần": "void sortDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "tạo mảng chứa số Fibonacci đầu tiên n số": "std::vector<int> generateFibonacci(int n) { std::vector<int> fib(n); if (n > 0) fib[0] = 0; if (n > 1) fib[1] = 1; for (int i = 2; i < n; ++i) fib[i] = fib[i - 1] + fib[i - 2]; return fib; }",
    "tìm phần tử lớn nhất trong danh sách liên kết": "int findMaxInList(const std::list<int>& lst) { return *std::max_element(lst.begin(), lst.end()); }",
    "tính tổng các số từ 1 đến n": "int sumUpTo(int n) { return n * (n + 1) / 2; }",
    "kiểm tra số có phải là số chính phương": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimesLessThan(int n) { int sum = 0; for (int i = 2; i < n; ++i) { bool isPrime = true; for (int j = 2; j <= std::sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) sum += i; } return sum; }",
    "kiểm tra một mảng có phải là mảng đối xứng": "bool isSymmetric(const std::vector<int>& arr) { return std::equal(arr.begin(), arr.begin() + arr.size() / 2, arr.rbegin()); }",
    "tính tổng các phần tử dương trong mảng": "int sumPositive(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int x) { return x > 0 ? acc + x : acc; }); }",
    "kiểm tra mảng có chứa giá trị lớn hơn n": "bool containsGreaterThan(const std::vector<int>& arr, int n) { return std::any_of(arr.begin(), arr.end(), [n](int x) { return x > n; }); }",
    "tìm phần tử nhỏ nhất trong danh sách": "int findMinInList(const std::list<int>& lst) { return *std::min_element(lst.begin(), lst.end()); }",
    "tạo mảng số nguyên từ n đến 1": "std::vector<int> createReverseArray(int n) { std::vector<int> arr(n); for (int i = 0; i < n; ++i) arr[i] = n - i; return arr; }",
    "tính số lượng ký tự số trong chuỗi": "int countDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isdigit); }",
    "tính số lượng ký tự chữ cái trong chuỗi": "int countLetters(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isalpha); }",
    "hoán đổi hai số bằng cách dùng XOR": "void swapXOR(int& a, int& b) { a ^= b; b ^= a; a ^= b; }",
    "kiểm tra một chuỗi có chứa chỉ ký tự chữ cái": "bool containsOnlyLetters(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isalpha); }",
    "tạo mảng với các số chính phương từ 1 đến n": "std::vector<int> generatePerfectSquares(int n) { std::vector<int> squares; for (int i = 1; i * i <= n; ++i) squares.push_back(i * i); return squares; }",
    "tính giai thừa của số n": "int factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); }",
    "tính số lượng số nguyên tố từ 1 đến n": "int countPrimesUpTo(int n) { int count = 0; for (int i = 2; i <= n; ++i) { bool isPrime = true; for (int j = 2; j <= std::sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) ++count; } return count; }",
    "tìm số lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tính tổng các phần tử trong ma trận": "int sumMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); } return sum; }",
    "kiểm tra số có phải là số hoàn hảo": "bool isPerfectNumber(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "hoán đổi hai số mà không dùng biến tạm": "void swapWithoutTemp(int& a, int& b) { a = a + b; b = a - b; a = a - b; }",
    "kiểm tra chuỗi có phải là anagram của chuỗi khác": "bool isAnagram(const std::string& str1, const std::string& str2) { if (str1.length() != str2.length()) return false; std::string sorted1 = str1; std::string sorted2 = str2; std::sort(sorted1.begin(), sorted1.end()); std::sort(sorted2.begin(), sorted2.end()); return sorted1 == sorted2; }",
    "tìm chỉ số của phần tử đầu tiên trong mảng lớn hơn giá trị cho trước": "int findFirstGreater(const std::vector<int>& arr, int value) { auto it = std::find_if(arr.begin(), arr.end(), [value](int x) { return x > value; }); return it != arr.end() ? std::distance(arr.begin(), it) : -1; }",
    "tạo ma trận số nguyên với giá trị mặc định": "std::vector<std::vector<int>> createMatrix(int rows, int cols, int defaultValue) { return std::vector<std::vector<int>>(rows, std::vector<int>(cols, defaultValue)); }",
    "tính số lượng phần tử chẵn trong mảng": "int countEvens(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int x) { return x % 2 == 0; }); }",
    "sắp xếp mảng theo thứ tự giảm dần": "void sortDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "tạo mảng chứa số Fibonacci đầu tiên n số": "std::vector<int> generateFibonacci(int n) { std::vector<int> fib(n); if (n > 0) fib[0] = 0; if (n > 1) fib[1] = 1; for (int i = 2; i < n; ++i) fib[i] = fib[i - 1] + fib[i - 2]; return fib; }",
    "tìm phần tử lớn nhất trong danh sách liên kết": "int findMaxInList(const std::list<int>& lst) { return *std::max_element(lst.begin(), lst.end()); }",
    "tính tổng các số từ 1 đến n": "int sumUpTo(int n) { return n * (n + 1) / 2; }",
    "kiểm tra số có phải là số chính phương": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimesLessThan(int n) { int sum = 0; for (int i = 2; i < n; ++i) { bool isPrime = true; for (int j = 2; j <= std::sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) sum += i; } return sum; }",
    "kiểm tra một mảng có phải là mảng đối xứng": "bool isSymmetric(const std::vector<int>& arr) { return std::equal(arr.begin(), arr.begin() + arr.size() / 2, arr.rbegin()); }",
    "tính tổng các phần tử dương trong mảng": "int sumPositive(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int x) { return x > 0 ? acc + x : acc; }); }",
    "kiểm tra mảng có chứa giá trị lớn hơn n": "bool containsGreaterThan(const std::vector<int>& arr, int n) { return std::any_of(arr.begin(), arr.end(), [n](int x) { return x > n; }); }",
    "tìm phần tử nhỏ nhất trong danh sách": "int findMinInList(const std::list<int>& lst) { return *std::min_element(lst.begin(), lst.end()); }",
    "tạo mảng số nguyên từ n đến 1": "std::vector<int> createReverseArray(int n) { std::vector<int> arr(n); for (int i = 0; i < n; ++i) arr[i] = n - i; return arr; }",
    "tính số lượng ký tự số trong chuỗi": "int countDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isdigit); }",
    "tính số lượng ký tự chữ cái trong chuỗi": "int countLetters(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isalpha); }",
    "hoán đổi hai số bằng cách dùng XOR": "void swapXOR(int& a, int& b) { a ^= b; b ^= a; a ^= b; }",
    "kiểm tra một chuỗi có chứa chỉ ký tự chữ cái": "bool containsOnlyLetters(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isalpha); }",
    "tạo mảng với các số chính phương từ 1 đến n": "std::vector<int> generatePerfectSquares(int n) { std::vector<int> squares; for (int i = 1; i * i <= n; ++i) squares.push_back(i * i); return squares; }",
    "tính tổng các số trong chuỗi số": "int sumStringNumbers(const std::string& str) { int sum = 0; std::istringstream ss(str); int num; while (ss >> num) sum += num; return sum; }",
    "kiểm tra chuỗi có phải là chuỗi con của chuỗi khác": "bool isSubstring(const std::string& str1, const std::string& str2) { return str1.find(str2) != std::string::npos; }",
    "tìm số âm đầu tiên trong mảng": "int findFirstNegative(const std::vector<int>& arr) { auto it = std::find_if(arr.begin(), arr.end(), [](int x) { return x < 0; }); return it != arr.end() ? *it : -1; }",
    "tạo mảng từ một danh sách liên kết": "std::vector<int> listToVector(const std::list<int>& lst) { return std::vector<int>(lst.begin(), lst.end()); }",
    "tìm kiếm giá trị trong ma trận": "bool findInMatrix(const std::vector<std::vector<int>>& matrix, int value) { for (const auto& row : matrix) { if (std::find(row.begin(), row.end(), value) != row.end()) return true; } return false; }",
    "sắp xếp mảng theo thứ tự tăng dần": "void sortAscending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end()); }",
    "tạo danh sách liên kết từ mảng": "std::list<int> vectorToList(const std::vector<int>& vec) { return std::list<int>(vec.begin(), vec.end()); }",
    "kiểm tra chuỗi có chứa ký tự đặc biệt": "bool containsSpecialChars(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char c) { return !std::isalnum(c); }); }",
    "tìm số nhỏ nhất trong mảng hai chiều": "int findMinInMatrix(const std::vector<std::vector<int>>& matrix) { int min = matrix[0][0]; for (const auto& row : matrix) { min = std::min(min, *std::min_element(row.begin(), row.end())); } return min; }",
    "tạo ma trận với giá trị ngẫu nhiên": "std::vector<std::vector<int>> createRandomMatrix(int rows, int cols, int minVal, int maxVal) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(minVal, maxVal); for (auto& row : matrix) { std::generate(row.begin(), row.end(), [&]() { return dis(gen); }); } return matrix; }",
    "tính trung bình cộng của các số trong mảng": "double average(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0.0) / arr.size(); }",
    "tạo chuỗi với ký tự lặp lại": "std::string repeatChar(char ch, int count) { return std::string(count, ch); }",
    "kiểm tra chuỗi có phải là chuỗi palindrome": "bool isPalindrome(const std::string& str) { return std::equal(str.begin(), str.begin() + str.size() / 2, str.rbegin()); }",
    "tính tổng các số chẵn từ 1 đến n": "int sumEvensUpTo(int n) { int sum = 0; for (int i = 2; i <= n; i += 2) sum += i; return sum; }",
    "tìm chuỗi dài nhất trong danh sách": "std::string findLongestString(const std::vector<std::string>& strs) { return *std::max_element(strs.begin(), strs.end(), [](const std::string& a, const std::string& b) { return a.length() < b.length(); }); }",
    "tạo ma trận đơn vị": "std::vector<std::vector<int>> createIdentityMatrix(int size) { std::vector<std::vector<int>> matrix(size, std::vector<int>(size, 0)); for (int i = 0; i < size; ++i) matrix[i][i] = 1; return matrix; }",
    "kiểm tra số có phải là số Armstrong": "bool isArmstrong(int num) { int sum = 0, original = num, digits = std::to_string(num).length(); while (num > 0) { int digit = num % 10; sum += std::pow(digit, digits); num /= 10; } return sum == original; }",
    "tạo mảng chứa số nguyên tố từ mảng đầu vào": "std::vector<int> filterPrimes(const std::vector<int>& arr) { std::vector<int> primes; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(num); } return primes; }",
    "tạo chuỗi từ danh sách số": "std::string joinNumbers(const std::list<int>& lst, char delimiter) { std::ostringstream oss; auto it = lst.begin(); if (it != lst.end()) { oss << *it; ++it; } for (; it != lst.end(); ++it) { oss << delimiter << *it; } return oss.str(); }",
    "kiểm tra chuỗi có phải là số nguyên": "bool isInteger(const std::string& str) { return !str.empty() && std::all_of(str.begin(), str.end(), ::isdigit); }",
    "tạo danh sách liên kết từ một chuỗi số": "std::list<int> createListFromString(const std::string& str) { std::list<int> lst; std::istringstream ss(str); int num; while (ss >> num) lst.push_back(num); return lst; }",
    "tạo mảng từ danh sách số nguyên tố": "std::vector<int> listToPrimes(const std::list<int>& lst) { std::vector<int> primes; for (int num : lst) { bool isPrime = num > 1; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(num); } return primes; }",
    "tính tổng các phần tử lẻ trong ma trận": "int sumOddsInMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0, [](int acc, int x) { return x % 2 != 0 ? acc + x : acc; }); } return sum; }",
    "tạo ma trận số nguyên tăng dần": "std::vector<std::vector<int>> createIncrementalMatrix(int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int value = 1; for (auto& row : matrix) { std::generate(row.begin(), row.end(), [&]() { return value++; }); } return matrix; }",
    "kiểm tra chuỗi có phải là chuỗi chữ thường": "bool isLowercase(const std::string& str) { return std::all_of(str.begin(), str.end(), ::islower); }",
    "tạo ma trận số nguyên với giá trị cố định": "std::vector<std::vector<int>> createMatrixWithValue(int rows, int cols, int value) { return std::vector<std::vector<int>>(rows, std::vector<int>(cols, value)); }",
    "kiểm tra một số có phải là số nguyên tố": "bool isPrime(int num) { if (num <= 1) return false; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) return false; } return true; }",
    "tìm số nguyên tố lớn nhất trong mảng": "int findMaxPrime(const std::vector<int>& arr) { int maxPrime = -1; for (int num : arr) { if (isPrime(num)) maxPrime = std::max(maxPrime, num); } return maxPrime; }",
    "tạo ma trận số nguyên từ n đến 1": "std::vector<std::vector<int>> createReverseMatrix(int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int value = rows * cols; for (auto& row : matrix) { for (auto& elem : row) { elem = value--; } } return matrix; }",
    "tính trung bình cộng của các phần tử lẻ trong mảng": "double averageOdds(const std::vector<int>& arr) { std::vector<int> odds; std::copy_if(arr.begin(), arr.end(), std::back_inserter(odds), [](int x) { return x % 2 != 0; }); return odds.empty() ? 0.0 : std::accumulate(odds.begin(), odds.end(), 0.0) / odds.size(); }",
    "kiểm tra chuỗi có phải là số thực": "bool isFloat(const std::string& str) { std::istringstream iss(str); float f; char c; return !(iss >> f).fail() && !(iss >> c).fail(); }",
    "tạo ma trận với các giá trị ngẫu nhiên trong khoảng": "std::vector<std::vector<int>> createRandomMatrixInRange(int rows, int cols, int minVal, int maxVal) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(minVal, maxVal); for (auto& row : matrix) { std::generate(row.begin(), row.end(), [&]() { return dis(gen); }); } return matrix; }",
    "tính số lượng số nguyên tố trong danh sách liên kết": "int countPrimesInList(const std::list<int>& lst) { int count = 0; for (int num : lst) { if (isPrime(num)) ++count; } return count; }",
    "tính tổng các số chính phương trong ma trận": "int sumPerfectSquaresInMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { for (int num : row) { if (isPerfectSquare(num)) sum += num; } } return sum; }",
    "tạo mảng từ danh sách các số thực": "std::vector<double> listToDoubleVector(const std::list<float>& lst) { return std::vector<double>(lst.begin(), lst.end()); }",
    "tạo ma trận số nguyên từ mảng một chiều": "std::vector<std::vector<int>> createMatrixFromArray(const std::vector<int>& arr, int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int index = 0; for (auto& row : matrix) { for (auto& elem : row) { if (index < arr.size()) elem = arr[index++]; } } return matrix; }",
    "tính tổng các phần tử chẵn trong danh sách liên kết": "int sumEvensInList(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0, [](int acc, int x) { return x % 2 == 0 ? acc + x : acc; }); }",
    "tạo ma trận với số lượng phần tử nhỏ nhất trong mảng": "std::vector<std::vector<int>> createMatrixWithMinValue(int rows, int cols, int minValue) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols, minValue)); return matrix; }",
    "kiểm tra một chuỗi có phải là số nguyên dương": "bool isPositiveInteger(const std::string& str) { return !str.empty() && std::all_of(str.begin(), str.end(), ::isdigit) && std::stoi(str) > 0; }",
    "tính tổng các số nguyên tố từ danh sách liên kết": "int sumPrimesInList(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0, [](int acc, int x) { return isPrime(x) ? acc + x : acc; }); }",
    "tạo ma trận với giá trị lớn nhất trong ma trận": "std::vector<std::vector<int>> createMatrixWithMaxValue(int rows, int cols, int maxValue) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols, maxValue)); return matrix; }",
    "kiểm tra chuỗi có phải là số thực dương": "bool isPositiveFloat(const std::string& str) { std::istringstream iss(str); float f; return (iss >> f) && f > 0; }",
    "tính trung bình cộng của các số trong ma trận": "double averageMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0, count = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); count += row.size(); } return count == 0 ? 0.0 : static_cast<double>(sum) / count; }",
    "tạo danh sách liên kết từ mảng số nguyên": "std::list<int> createListFromArray(const std::vector<int>& arr) { return std::list<int>(arr.begin(), arr.end()); }",
    "tính tổng các số hoàn hảo trong danh sách liên kết": "int sumPerfectNumbersInList(const std::list<int>& lst) { int sum = 0; for (int num : lst) { if (isPerfectNumber(num)) sum += num; } return sum; }",
    "tìm số nguyên tố nhỏ nhất trong mảng": "int findMinPrime(const std::vector<int>& arr) { int minPrime = -1; for (int num : arr) { if (isPrime(num)) minPrime = std::min(minPrime, num); } return minPrime; }",
    "tạo ma trận số nguyên từ giá trị cố định": "std::vector<std::vector<int>> createMatrixWithConstantValue(int rows, int cols, int value) { return std::vector<std::vector<int>>(rows, std::vector<int>(cols, value)); }",
    "tính tổng các số chính phương từ mảng": "int sumPerfectSquares(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int x) { return isPerfectSquare(x) ? acc + x : acc; }); }",
    "tạo ma trận từ giá trị tăng dần": "std::vector<std::vector<int>> createIncrementalMatrixFromValue(int rows, int cols, int startValue) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int value = startValue; for (auto& row : matrix) { std::generate(row.begin(), row.end(), [&]() { return value++; }); } return matrix; }",
    "tính số lượng số chính phương trong danh sách liên kết": "int countPerfectSquaresInList(const std::list<int>& lst) { return std::count_if(lst.begin(), lst.end(), [](int x) { return isPerfectSquare(x); }); }",
    "kiểm tra số có phải là số chính phương": "bool isPerfectSquare(int num) { int sqrtNum = static_cast<int>(std::sqrt(num)); return sqrtNum * sqrtNum == num; }",
    "tạo ma trận từ mảng số nguyên tố": "std::vector<std::vector<int>> createMatrixFromPrimes(const std::vector<int>& primes, int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int index = 0; for (auto& row : matrix) { for (auto& elem : row) { if (index < primes.size()) elem = primes[index++]; } } return matrix; }",
    "tính số lượng số chính phương trong mảng": "int countPerfectSquares(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int x) { return isPerfectSquare(x); }); }",
    "tạo danh sách liên kết từ mảng số thực": "std::list<float> createListFromFloatArray(const std::vector<float>& arr) { return std::list<float>(arr.begin(), arr.end()); }",
    "tính tổng các số chính phương trong danh sách liên kết": "int sumPerfectSquaresInList(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0, [](int acc, int x) { return isPerfectSquare(x) ? acc + x : acc; }); }",
    "kiểm tra số có phải là số hoàn hảo": "bool isPerfectNumber(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "tạo ma trận với số lượng phần tử chính phương": "std::vector<std::vector<int>> createMatrixWithPerfectSquares(int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int value = 1; for (auto& row : matrix) { for (auto& elem : row) { while (!isPerfectSquare(value)) ++value; elem = value++; } } return matrix; }",
    "tính tổng các số hoàn hảo trong mảng": "int sumPerfectNumbers(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int x) { return isPerfectNumber(x) ? acc + x : acc; }); }",
    "tạo ma trận từ giá trị ngẫu nhiên với kích thước": "std::vector<std::vector<int>> createMatrixWithRandomValues(int rows, int cols, int minValue, int maxValue) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(minValue, maxValue); for (auto& row : matrix) { std::generate(row.begin(), row.end(), [&]() { return dis(gen); }); } return matrix; }",
    "kiểm tra số có phải là số hoàn hảo trong ma trận": "bool isPerfectNumberInMatrix(const std::vector<std::vector<int>>& matrix, int num) { for (const auto& row : matrix) { if (std::find(row.begin(), row.end(), num) != row.end()) return isPerfectNumber(num); } return false; }",
    "tạo ma trận từ số nguyên tố trong danh sách liên kết": "std::vector<std::vector<int>> createMatrixFromPrimeList(const std::list<int>& lst, int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int index = 0; for (auto& row : matrix) { for (auto& elem : row) { if (index < lst.size()) elem = *std::next(lst.begin(), index++); } } return matrix; }",
    "tính số lượng số hoàn hảo trong mảng": "int countPerfectNumbers(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int x) { return isPerfectNumber(x); }); }",
    "tạo ma trận số nguyên với các giá trị liên tiếp": "std::vector<std::vector<int>> createMatrixWithConsecutiveValues(int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); int value = 1; for (auto& row : matrix) { for (auto& elem : row) { elem = value++; } } return matrix; }",
    "kiểm tra số nguyên tố": "bool isPrime(int num) { if (num <= 1) return false; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) return false; } return true; }",
    "kiểm tra số hoàn hảo": "bool isPerfectNumber(int num) { int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int num) { int root = sqrt(num); return root * root == num; }",
    "kiểm tra số chẵn": "bool isEven(int num) { return num % 2 == 0; }",
    "kiểm tra số lẻ": "bool isOdd(int num) { return num % 2 != 0; }",
    "kiểm tra số palindrome": "bool isPalindrome(int num) { std::string s = std::to_string(num); std::string reversed = s; std::reverse(reversed.begin(), reversed.end()); return s == reversed; }",
    "kiểm tra số Fibonacci": "bool isFibonacci(int num) { int a = 0, b = 1; while (a < num) { int temp = a; a = b; b = temp + b; } return a == num; }",
    "tạo chuỗi số Fibonacci": "std::vector<int> generateFibonacciSequence(int n) { std::vector<int> fib; int a = 0, b = 1; while (n-- > 0) { fib.push_back(a); int temp = a; a = b; b = temp + b; } return fib; }",
    "tạo chuỗi số nguyên tố": "std::vector<int> generatePrimeNumbers(int n) { std::vector<int> primes; for (int num = 2; primes.size() < n; ++num) { if (isPrime(num)) primes.push_back(num); } return primes; }",
    "tạo chuỗi số hoàn hảo": "std::vector<int> generatePerfectNumbers(int n) { std::vector<int> perfects; int i = 2; while (perfects.size() < n) { if (isPerfectNumber(i)) perfects.push_back(i); ++i; } return perfects; }",
    "tạo chuỗi số chính phương": "std::vector<int> generatePerfectSquares(int n) { std::vector<int> squares; int i = 1; while (squares.size() < n) { squares.push_back(i * i); ++i; } return squares; }",
    "tìm giá trị lớn nhất trong vector": "int findMaxInVector(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "tìm giá trị nhỏ nhất trong vector": "int findMinInVector(const std::vector<int>& vec) { return *std::min_element(vec.begin(), vec.end()); }",
    "sắp xếp vector tăng dần": "std::vector<int> sortVectorAscending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end()); return vec; }",
    "sắp xếp vector giảm dần": "std::vector<int> sortVectorDescending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "đếm số lẻ trong list": "int countOddNumbersInList(const std::list<int>& lst) { return std::count_if(lst.begin(), lst.end(), [](int x) { return x % 2 != 0; }); }",
    "đếm số chẵn trong list": "int countEvenNumbersInList(const std::list<int>& lst) { return std::count_if(lst.begin(), lst.end(), [](int x) { return x % 2 == 0; }); }",
    "kiểm tra chuỗi palindrome": "bool isPalindromeString(const std::string& str) { std::string reversed = str; std::reverse(reversed.begin(), reversed.end()); return str == reversed; }",
    "đảo ngược chuỗi": "std::string reverseString(const std::string& str) { std::string reversed = str; std::reverse(reversed.begin(), reversed.end()); return reversed; }",
    "tính tổng các chữ số": "int sumDigits(int num) { int sum = 0; while (num > 0) { sum += num % 10; num /= 10; } return sum; }",
    "tạo số nguyên ngẫu nhiên": "std::vector<int> generateRandomIntegers(int n, int minValue, int maxValue) { std::vector<int> randomNumbers(n); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(minValue, maxValue); std::generate(randomNumbers.begin(), randomNumbers.end(), [&]() { return dis(gen); }); return randomNumbers; }",
    "tính tổng các bội số của 3 trong vector": "int sumOfMultiplesOfThree(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int x) { return x % 3 == 0 ? sum + x : sum; }); }",
    "lọc số lẻ trong vector": "std::vector<int> filterOddNumbers(const std::vector<int>& vec) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [](int x) { return x % 2 != 0; }); return result; }",
    "lọc số chẵn trong vector": "std::vector<int> filterEvenNumbers(const std::vector<int>& vec) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [](int x) { return x % 2 == 0; }); return result; }",
    "lọc số nguyên tố trong vector": "std::vector<int> filterPrimes(const std::vector<int>& vec) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [](int x) { return isPrime(x); }); return result; }",
    "tính giai thừa của số": "int factorial(int n) { int result = 1; for (int i = 2; i <= n; ++i) result *= i; return result; }",
    "tính lũy thừa của cơ số": "int power(int base, int exp) { int result = 1; while (exp > 0) { if (exp % 2 == 1) result *= base; base *= base; exp /= 2; } return result; }",
    "tìm số lớn thứ hai trong vector": "int findSecondLargestInVector(const std::vector<int>& vec) { int largest = INT_MIN, second = INT_MIN; for (int num : vec) { if (num > largest) { second = largest; largest = num; } else if (num > second && num < largest) { second = num; } } return second; }",
    "tìm số nhỏ thứ hai trong vector": "int findSecondSmallestInVector(const std::vector<int>& vec) { int smallest = INT_MAX, second = INT_MAX; for (int num : vec) { if (num < smallest) { second = smallest; smallest = num; } else if (num < second && num > smallest) { second = num; } } return second; }",
    "tính tổng các số nguyên tố trong vector": "int sumPrimesInVector(const std::vector<int>& vec) { int sum = 0; for (int num : vec) { if (isPrime(num)) sum += num; } return sum; }",
    "tạo chuỗi số hoàn hảo nhỏ hơn n": "std::vector<int> generatePerfectNumbersLessThan(int n) { std::vector<int> perfects; int i = 2; while (i < n) { if (isPerfectNumber(i)) perfects.push_back(i); ++i; } return perfects; }",
    "chèn phần tử vào vector": "void insertIntoVector(std::vector<int>& vec, int index, int value) { if (index >= 0 && index <= vec.size()) vec.insert(vec.begin() + index, value); }",
    "xóa phần tử khỏi vector": "void removeFromVector(std::vector<int>& vec, int value) { vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end()); }",
    "tìm vị trí của phần tử trong vector": "int findPositionInVector(const std::vector<int>& vec, int value) { auto it = std::find(vec.begin(), vec.end(), value); return (it != vec.end()) ? std::distance(vec.begin(), it) : -1; }",
    "tính trung bình của vector": "double calculateAverage(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size(); }",
    "tạo ma trận vuông": "std::vector<std::vector<int>> createSquareMatrix(int size, int initialValue) { return std::vector<std::vector<int>>(size, std::vector<int>(size, initialValue)); }",
    "tính tổng các phần tử của ma trận": "int sumMatrixElements(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); } return sum; }",
    "nhân ma trận 2x2": "std::vector<std::vector<int>> multiply2x2Matrices(const std::vector<std::vector<int>>& a, const std::vector<std::vector<int>>& b) { std::vector<std::vector<int>> result(2, std::vector<int>(2, 0)); for (int i = 0; i < 2; ++i) { for (int j = 0; j < 2; ++j) { for (int k = 0; k < 2; ++k) { result[i][j] += a[i][k] * b[k][j]; } } } return result; }",
    "chuyển đổi chữ hoa thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "chuyển đổi chữ thường thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "tạo chuỗi từ ký tự": "std::string createStringFromChar(char c, int times) { return std::string(times, c); }",
    "tách chuỗi thành từ": "std::vector<std::string> splitString(const std::string& str, char delimiter) { std::vector<std::string> tokens; std::stringstream ss(str); std::string token; while (std::getline(ss, token, delimiter)) { tokens.push_back(token); } return tokens; }",
    "nối các chuỗi trong vector": "std::string concatenateStrings(const std::vector<std::string>& vec) { std::ostringstream oss; for (const auto& s : vec) { oss << s; } return oss.str(); }",
    "tạo chuỗi ngẫu nhiên": "std::string generateRandomString(size_t length) { const std::string characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; std::string result; std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(0, characters.size() - 1); for (size_t i = 0; i < length; ++i) { result += characters[dis(gen)]; } return result; }",
    "đếm số từ trong chuỗi": "int countWordsInString(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "tạo vector từ dãy số": "std::vector<int> createVectorFromRange(int start, int end) { std::vector<int> vec; for (int i = start; i <= end; ++i) { vec.push_back(i); } return vec; }",
    "đảo ngược phần tử của vector": "void reverseVector(std::vector<int>& vec) { std::reverse(vec.begin(), vec.end()); }",
    "kiểm tra phần tử có tồn tại trong set": "bool existsInSet(const std::set<int>& s, int value) { return s.find(value) != s.end(); }",
    "tạo set từ vector": "std::set<int> createSetFromVector(const std::vector<int>& vec) { return std::set<int>(vec.begin(), vec.end()); }",
    "tạo map từ vector": "std::map<int, int> createMapFromVector(const std::vector<int>& vec) { std::map<int, int> m; for (size_t i = 0; i < vec.size(); ++i) { m[i] = vec[i]; } return m; }",
    "tìm giá trị của khóa trong map": "int findValueInMap(const std::map<int, int>& m, int key) { auto it = m.find(key); return (it != m.end()) ? it->second : -1; }",
    "chèn phần tử vào map": "void insertIntoMap(std::map<int, int>& m, int key, int value) { m[key] = value; }",
    "xóa khóa khỏi map": "void removeFromMap(std::map<int, int>& m, int key) { m.erase(key); }",
    "tính số lượng phần tử trong map": "int countElementsInMap(const std::map<int, int>& m) { return m.size(); }",
    "chèn phần tử vào set": "void insertIntoSet(std::set<int>& s, int value) { s.insert(value); }",
    "xóa phần tử khỏi set": "void removeFromSet(std::set<int>& s, int value) { s.erase(value); }",
    "tạo vector từ set": "std::vector<int> createVectorFromSet(const std::set<int>& s) { return std::vector<int>(s.begin(), s.end()); }",
    "tạo vector từ map": "std::vector<int> createVectorFromMap(const std::map<int, int>& m) { std::vector<int> vec; for (const auto& pair : m) { vec.push_back(pair.second); } return vec; }",
    "tạo map từ set": "std::map<int, int> createMapFromSet(const std::set<int>& s) { std::map<int, int> m; int index = 0; for (int value : s) { m[index++] = value; } return m; }",
    "tạo set từ map": "std::set<int> createSetFromMap(const std::map<int, int>& m) { std::set<int> s; for (const auto& pair : m) { s.insert(pair.second); } return s; }",
    "tính tổng các phần tử của list": "int sumListElements(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0); }",
    "tính trung bình của list": "double calculateAverageList(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0.0) / lst.size(); }",
    "tạo list từ vector": "std::list<int> createListFromVector(const std::vector<int>& vec) { return std::list<int>(vec.begin(), vec.end()); }",
    "tạo vector từ list": "std::vector<int> createVectorFromList(const std::list<int>& lst) { return std::vector<int>(lst.begin(), lst.end()); }",
    "kiểm tra số là số nguyên tố": "bool isPrimeNumber(int num) { if (num <= 1) return false; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) return false; } return true; }",
    "tạo mảng động": "int* createDynamicArray(int size) { return new int[size]; }",
    "giải phóng mảng động": "void freeDynamicArray(int* arr) { delete[] arr; }",
    "tạo chuỗi từ ký tự và số lần xuất hiện": "std::string createString(char ch, int count) { return std::string(count, ch); }",
    "chèn phần tử vào danh sách liên kết": "void insertIntoLinkedList(std::list<int>& lst, int value) { lst.push_back(value); }",
    "xóa phần tử khỏi danh sách liên kết": "void removeFromLinkedList(std::list<int>& lst, int value) { lst.remove(value); }",
    "tạo danh sách liên kết từ vector": "std::list<int> createLinkedListFromVector(const std::vector<int>& vec) { return std::list<int>(vec.begin(), vec.end()); }",
    "tạo vector từ danh sách liên kết": "std::vector<int> createVectorFromLinkedList(const std::list<int>& lst) { return std::vector<int>(lst.begin(), lst.end()); }",
    "chèn phần tử vào hàng đợi": "void enqueue(std::queue<int>& q, int value) { q.push(value); }",
    "xóa phần tử khỏi hàng đợi": "void dequeue(std::queue<int>& q) { if (!q.empty()) q.pop(); }",
    "xem phần tử đầu hàng đợi": "int peekQueue(const std::queue<int>& q) { return (q.empty()) ? -1 : q.front(); }",
    "tạo chuỗi số chính phương nhỏ hơn n": "std::vector<int> generatePerfectSquaresLessThan(int n) { std::vector<int> squares; int i = 1; while (i * i < n) { squares.push_back(i * i); ++i; } return squares; }",
    "sắp xếp mảng theo thứ tự tăng dần": "void sortArrayAsc(int* arr, int size) { std::sort(arr, arr + size); }",
    "sắp xếp mảng theo thứ tự giảm dần": "void sortArrayDesc(int* arr, int size) { std::sort(arr, arr + size, std::greater<int>()); }",
    "tìm phần tử lớn nhất trong mảng": "int findMaxInArray(const int* arr, int size) { return *std::max_element(arr, arr + size); }",
    "tìm phần tử nhỏ nhất trong mảng": "int findMinInArray(const int* arr, int size) { return *std::min_element(arr, arr + size); }",
    "tính tổng các phần tử trong mảng": "int sumArray(const int* arr, int size) { return std::accumulate(arr, arr + size, 0); }",
    "tính tích các phần tử trong mảng": "int productArray(const int* arr, int size) { return std::accumulate(arr, arr + size, 1, std::multiplies<int>()); }",
    "tạo mảng từ phạm vi số nguyên": "int* createArrayFromRange(int start, int end) { int size = end - start + 1; int* arr = new int[size]; for (int i = 0; i < size; ++i) { arr[i] = start + i; } return arr; }",
    "tạo ma trận từ vector": "std::vector<std::vector<int>> createMatrixFromVector(const std::vector<int>& vec, int rows, int cols) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { matrix[i][j] = vec[i * cols + j]; } } return matrix; }",
    "chèn phần tử vào ma trận": "void insertIntoMatrix(std::vector<std::vector<int>>& matrix, int row, int col, int value) { if (row < matrix.size() && col < matrix[0].size()) matrix[row][col] = value; }",
    "xóa phần tử khỏi ma trận": "void removeFromMatrix(std::vector<std::vector<int>>& matrix, int row, int col) { if (row < matrix.size() && col < matrix[0].size()) matrix[row][col] = 0; }",
    "tính tổng các phần tử trong ma trận": "int sumMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); } return sum; }",
    "tạo vector từ ma trận": "std::vector<int> createVectorFromMatrix(const std::vector<std::vector<int>>& matrix) { std::vector<int> vec; for (const auto& row : matrix) { vec.insert(vec.end(), row.begin(), row.end()); } return vec; }",
    "kiểm tra ma trận có phải là ma trận vuông không": "bool isSquareMatrix(const std::vector<std::vector<int>>& matrix) { return matrix.size() > 0 && matrix.size() == matrix[0].size(); }",
    "tạo chuỗi từ một số nguyên": "std::string intToString(int num) { return std::to_string(num); }",
    "tạo số nguyên từ chuỗi": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "đổi chỗ hai số nguyên": "void swap(int& a, int& b) { int temp = a; a = b; b = temp; }",
    "chèn phần tử vào stack": "void pushStack(std::stack<int>& s, int value) { s.push(value); }",
    "xóa phần tử khỏi stack": "void popStack(std::stack<int>& s) { if (!s.empty()) s.pop(); }",
    "xem phần tử trên cùng của stack": "int topStack(const std::stack<int>& s) { return (s.empty()) ? -1 : s.top(); }",
    "chèn phần tử vào queue": "void enqueueQueue(std::queue<int>& q, int value) { q.push(value); }",
    "xóa phần tử khỏi queue": "void dequeueQueue(std::queue<int>& q) { if (!q.empty()) q.pop(); }",
    "xem phần tử đầu của queue": "int frontQueue(const std::queue<int>& q) { return (q.empty()) ? -1 : q.front(); }",
    "chèn phần tử vào priority_queue": "void pushPriorityQueue(std::priority_queue<int>& pq, int value) { pq.push(value); }",
    "xóa phần tử khỏi priority_queue": "void popPriorityQueue(std::priority_queue<int>& pq) { if (!pq.empty()) pq.pop(); }",
    "xem phần tử lớn nhất của priority_queue": "int topPriorityQueue(const std::priority_queue<int>& pq) { return (pq.empty()) ? -1 : pq.top(); }",
    "tạo list từ mảng": "std::list<int> createListFromArray(const int* arr, int size) { return std::list<int>(arr, arr + size); }",
    "tạo mảng từ list": "int* createArrayFromList(const std::list<int>& lst) { int size = lst.size(); int* arr = new int[size]; std::copy(lst.begin(), lst.end(), arr); return arr; }",
    "kiểm tra số nguyên tố": "bool isPrime(int num) { if (num <= 1) return false; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) return false; } return true; }",
    "tính giai thừa của số nguyên": "int factorial(int n) { return (n <= 1) ? 1 : n * factorial(n - 1); }",
    "tính số Fibonacci": "int fibonacci(int n) { return (n <= 1) ? n : fibonacci(n - 1) + fibonacci(n - 2); }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int num) { int sq_root = sqrt(num); return sq_root * sq_root == num; }",
    "tạo chuỗi số từ 1 đến n": "std::string createNumberString(int n) { std::ostringstream oss; for (int i = 1; i <= n; ++i) { oss << i << ' '; } return oss.str(); }",
    "tính tổng các số trong một khoảng": "int sumRange(int start, int end) { int sum = 0; for (int i = start; i <= end; ++i) { sum += i; } return sum; }",
    "tạo mảng 2 chiều với giá trị mặc định": "std::vector<std::vector<int>> createMatrix(int rows, int cols, int value) { return std::vector<std::vector<int>>(rows, std::vector<int>(cols, value)); }",
    "chuyển đổi ký tự thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "chuyển đổi ký tự thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "kiểm tra chuỗi có phải là số nguyên không": "bool isInteger(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isdigit); }",
    "tạo chuỗi từ một ký tự lặp lại": "std::string createRepeatedCharString(char ch, int times) { return std::string(times, ch); }",
    "tìm số nguyên tố đầu tiên lớn hơn n": "int nextPrime(int n) { int num = n + 1; while (true) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) return num; ++num; } }",
    "tìm phần tử xuất hiện nhiều nhất trong mảng": "int mostFrequentElement(const std::vector<int>& arr) { std::unordered_map<int, int> count; for (int num : arr) { count[num]++; } return std::max_element(count.begin(), count.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->first; }",
    "xóa phần tử khỏi vector theo giá trị": "void removeElement(std::vector<int>& vec, int value) { vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end()); }",
    "kiểm tra số hoàn hảo": "bool isPerfectNumber(int num) { int sum = 1; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { sum += i; if (i != num / i) sum += num / i; } } return sum == num && num != 1; }",
    "tạo ma trận xoay 90 độ": "std::vector<std::vector<int>> rotateMatrix90(const std::vector<std::vector<int>>& matrix) { int n = matrix.size(); std::vector<std::vector<int>> rotated(n, std::vector<int>(n)); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { rotated[j][n - 1 - i] = matrix[i][j]; } } return rotated; }",
    "tính tổng của số Fibonacci nhỏ hơn n": "int sumFibonacciLessThan(int n) { int a = 0, b = 1, sum = 0; while (a < n) { sum += a; int temp = a; a = b; b = temp + b; } return sum; }",
    "kiểm tra chuỗi có chứa số không": "bool containsNumber(const std::string& str) { return std::any_of(str.begin(), str.end(), ::isdigit); }",
    "chèn phần tử vào vị trí cụ thể trong vector": "void insertAt(std::vector<int>& vec, int index, int value) { if (index >= 0 && index <= vec.size()) vec.insert(vec.begin() + index, value); }",
    "xóa phần tử ở vị trí cụ thể trong vector": "void eraseAt(std::vector<int>& vec, int index) { if (index >= 0 && index < vec.size()) vec.erase(vec.begin() + index); }",
    "tạo vector ngẫu nhiên từ phạm vi": "std::vector<int> generateRandomVector(int size, int min, int max) { std::vector<int> vec(size); std::generate(vec.begin(), vec.end(), [min, max]() { return rand() % (max - min + 1) + min; }); return vec; }",
    "tính số lượng phần tử âm trong vector": "int countNegative(const std::vector<int>& vec) { return std::count_if(vec.begin(), vec.end(), [](int x) { return x < 0; }); }",
    "tạo chuỗi từ số nguyên chia nhỏ thành nhóm 3 chữ số": "std::string formatNumber(int num) { std::string str = std::to_string(num); std::reverse(str.begin(), str.end()); for (size_t i = 3; i < str.size(); i += 4) str.insert(i, 1, ','); std::reverse(str.begin(), str.end()); return str; }",
    "tính số lượng từ trong chuỗi": "int wordCount(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "tìm số lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tìm số nhỏ nhất trong mảng": "int findMin(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end()); }",
    "sắp xếp mảng theo thứ tự giảm dần": "void sortDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "tính tổng các số chẵn trong mảng": "int sumEven(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 == 0 ? sum + num : sum; }); }",
    "tính tổng các số lẻ trong mảng": "int sumOdd(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 != 0 ? sum + num : sum; }); }",
    "tính số lượng ký tự trong chuỗi": "int countCharacters(const std::string& str) { return str.size(); }",
    "kiểm tra chuỗi có chứa ký tự đặc biệt không": "bool containsSpecialChar(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char c) { return !std::isalnum(c); }); }",
    "tạo chuỗi từ mảng ký tự": "std::string createStringFromArray(const std::vector<char>& arr) { return std::string(arr.begin(), arr.end()); }",
    "đảo ngược chuỗi": "std::string reverseString(const std::string& str) { return std::string(str.rbegin(), str.rend()); }",
    "tìm vị trí của một ký tự trong chuỗi": "size_t findCharPosition(const std::string& str, char ch) { return str.find(ch); }",
    "chèn chuỗi vào một vị trí cụ thể trong chuỗi khác": "std::string insertString(const std::string& base, const std::string& toInsert, size_t position) { std::string result = base; result.insert(position, toInsert); return result; }",
    "xóa phần tử đầu tiên khỏi vector": "void removeFirstElement(std::vector<int>& vec) { if (!vec.empty()) vec.erase(vec.begin()); }",
    "xóa phần tử cuối cùng khỏi vector": "void removeLastElement(std::vector<int>& vec) { if (!vec.empty()) vec.pop_back(); }",
    "tạo vector từ một phạm vi số nguyên": "std::vector<int> createVectorRange(int start, int end) { std::vector<int> vec(end - start + 1); std::iota(vec.begin(), vec.end(), start); return vec; }",
    "tìm số nguyên tố trong một phạm vi": "std::vector<int> primesInRange(int start, int end) { std::vector<int> primes; for (int num = start; num <= end; ++num) { bool isPrime = num > 1; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(num); } return primes; }",
    "tính giai thừa của một số": "unsigned long long factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); }",
    "tạo ma trận đơn vị": "std::vector<std::vector<int>> createIdentityMatrix(int size) { std::vector<std::vector<int>> matrix(size, std::vector<int>(size, 0)); for (int i = 0; i < size; ++i) matrix[i][i] = 1; return matrix; }",
    "chuyển đổi chuỗi thành số nguyên": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "chuyển đổi số nguyên thành chuỗi": "std::string intToString(int num) { return std::to_string(num); }",
    "tìm phần tử nhỏ nhất lớn hơn n trong vector": "int findNextGreaterElement(const std::vector<int>& vec, int n) { auto it = std::upper_bound(vec.begin(), vec.end(), n); return it != vec.end() ? *it : -1; }",
    "tính số lượng ký tự số trong chuỗi": "int countDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isdigit); }",
    "tính tổng của tất cả các số trong vector": "int sumVector(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0); }",
    "tìm giá trị lớn nhất trong ma trận": "int findMaxInMatrix(const std::vector<std::vector<int>>& matrix) { return *std::max_element(matrix.begin(), matrix.end(), [](const std::vector<int>& a, const std::vector<int>& b) { return *std::max_element(a.begin(), a.end()) < *std::max_element(b.begin(), b.end()); }); }",
    "tính tổng các phần tử của ma trận": "int sumMatrix(const std::vector<std::vector<int>>& matrix) { int sum = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); } return sum; }",
    "tìm số nguyên tố đầu tiên lớn hơn n": "int nextPrime(int n) { while (true) { ++n; bool isPrime = true; for (int i = 2; i <= sqrt(n); ++i) { if (n % i == 0) { isPrime = false; break; } } if (isPrime) return n; } }",
    "kiểm tra chuỗi có chứa chữ số không": "bool containsDigit(const std::string& str) { return std::any_of(str.begin(), str.end(), ::isdigit); }",
    "tạo một vector chứa số nguyên tố từ 1 đến n": "std::vector<int> primesUpTo(int n) { std::vector<int> primes; for (int i = 2; i <= n; ++i) { bool isPrime = true; for (int j = 2; j <= sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(i); } return primes; }",
    "tạo chuỗi từ các phần tử của vector": "std::string vectorToString(const std::vector<int>& vec) { std::ostringstream oss; for (const int& num : vec) { oss << num << ' '; } return oss.str(); }",
    "tính trung bình cộng của các số trong vector": "double averageVector(const std::vector<int>& vec) { return static_cast<double>(sumVector(vec)) / vec.size(); }",
    "tìm chỉ số của phần tử đầu tiên lớn hơn một giá trị nhất định": "int findFirstGreater(const std::vector<int>& vec, int value) { auto it = std::find_if(vec.begin(), vec.end(), [value](int num) { return num > value; }); return it != vec.end() ? std::distance(vec.begin(), it) : -1; }",
    "đảo ngược vector": "void reverseVector(std::vector<int>& vec) { std::reverse(vec.begin(), vec.end()); }",
    "kiểm tra chuỗi có phải là số không": "bool isNumber(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isdigit); }",
    "chèn một phần tử vào vị trí cụ thể trong vector": "void insertIntoVector(std::vector<int>& vec, int value, size_t position) { if (position <= vec.size()) vec.insert(vec.begin() + position, value); }",
    "xóa tất cả các số âm khỏi vector": "void removeNegative(std::vector<int>& vec) { vec.erase(std::remove_if(vec.begin(), vec.end(), [](int num) { return num < 0; }), vec.end()); }",
    "tạo vector từ một chuỗi số cách nhau bởi dấu cách": "std::vector<int> stringToVector(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); int num; while (iss >> num) vec.push_back(num); return vec; }",
    "sắp xếp ma trận theo thứ tự tăng dần": "void sortMatrix(std::vector<std::vector<int>>& matrix) { for (auto& row : matrix) { std::sort(row.begin(), row.end()); } }",
    "chèn một phần tử vào vector nếu nó không tồn tại": "void insertIfNotExists(std::vector<int>& vec, int value) { if (std::find(vec.begin(), vec.end(), value) == vec.end()) vec.push_back(value); }",
    "tính tổng các số chính phương trong vector": "int sumPerfectSquares(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { int sqrtNum = static_cast<int>(sqrt(num)); return sqrtNum * sqrtNum == num ? sum + num : sum; }); }",
    "tìm phần tử lớn thứ ba trong vector": "int thirdLargest(const std::vector<int>& vec) { std::set<int, std::greater<int>> sortedSet(vec.begin(), vec.end()); auto it = sortedSet.begin(); std::advance(it, 2); return (it != sortedSet.end()) ? *it : -1; }",
    "kiểm tra nếu một mảng có tất cả các phần tử đều khác nhau": "bool allUnique(const std::vector<int>& vec) { std::set<int> uniqueElements(vec.begin(), vec.end()); return uniqueElements.size() == vec.size(); }",
    "tính tổng tất cả các số chẵn trong vector": "int sumEven(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { return num % 2 == 0 ? sum + num : sum; }); }",
    "tạo ma trận vuông n x n với tất cả các phần tử bằng giá trị cụ thể": "std::vector<std::vector<int>> createMatrix(int n, int value) { return std::vector<std::vector<int>>(n, std::vector<int>(n, value)); }",
    "tạo vector từ ma trận (trả về các phần tử theo hàng)": "std::vector<int> matrixToVector(const std::vector<std::vector<int>>& matrix) { std::vector<int> vec; for (const auto& row : matrix) { vec.insert(vec.end(), row.begin(), row.end()); } return vec; }",
    "tìm phần tử xuất hiện nhiều nhất trong vector": "int mostFrequent(const std::vector<int>& vec) { std::unordered_map<int, int> count; for (int num : vec) ++count[num]; return std::max_element(count.begin(), count.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->first; }",
    "đếm số lượng ký tự chữ cái trong chuỗi": "int countLetters(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isalpha); }",
    "tạo vector với các số từ 1 đến n": "std::vector<int> createSequentialVector(int n) { std::vector<int> vec(n); std::iota(vec.begin(), vec.end(), 1); return vec; }",
    "tìm phần tử nhỏ nhất trong vector không bao gồm phần tử cụ thể": "int findMinExcluding(const std::vector<int>& vec, int exclude) { return *std::min_element(vec.begin(), vec.end(), [exclude](int a, int b) { return a != exclude && (b == exclude || a < b); }); }",
    "chuyển đổi chữ hoa thành chữ thường trong chuỗi": "std::string toLowerCase(const std::string& str) { std::string lowerStr = str; std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower); return lowerStr; }",
    "chuyển đổi chữ thường thành chữ hoa trong chuỗi": "std::string toUpperCase(const std::string& str) { std::string upperStr = str; std::transform(upperStr.begin(), upperStr.end(), upperStr.begin(), ::toupper); return upperStr; }",
    "tạo ma trận số nguyên ngẫu nhiên": "std::vector<std::vector<int>> generateRandomMatrix(int rows, int cols, int minValue, int maxValue) { std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols)); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(minValue, maxValue); for (auto& row : matrix) { for (auto& elem : row) { elem = dis(gen); } } return matrix; }",
    "kiểm tra vector có phải là vector số nguyên tố không": "bool areAllPrimes(const std::vector<int>& vec) { return std::all_of(vec.begin(), vec.end(), [](int num) { if (num < 2) return false; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) return false; } return true; }); }",
    "tính tổng các số nguyên tố trong ma trận": "int sumPrimesInMatrix(const std::vector<std::vector<int>>& matrix) { return std::accumulate(matrix.begin(), matrix.end(), 0, [](int sum, const std::vector<int>& row) { return sum + std::accumulate(row.begin(), row.end(), 0, [](int sum, int num) { return isPrime(num) ? sum + num : sum; }); }); }",
    "tạo chuỗi từ các ký tự số trong một vector": "std::string vectorToDigitString(const std::vector<int>& vec) { std::ostringstream oss; for (int num : vec) { if (num >= 0 && num <= 9) oss << static_cast<char>('0' + num); } return oss.str(); }",
    "kiểm tra số nguyên có phải là số chính phương không": "bool isPerfectSquare(int num) { int root = static_cast<int>(sqrt(num)); return root * root == num; }",
    "tính số lượng số chính phương trong vector": "int countPerfectSquares(const std::vector<int>& vec) { return std::count_if(vec.begin(), vec.end(), [](int num) { return isPerfectSquare(num); }); }",
    "tìm số nhỏ nhất trong ma trận": "int findMinInMatrix(const std::vector<std::vector<int>>& matrix) { return *std::min_element(matrix.begin(), matrix.end(), [](const std::vector<int>& a, const std::vector<int>& b) { return *std::min_element(a.begin(), a.end()) < *std::min_element(b.begin(), b.end()); }); }",
    "tính số lượng ký tự đặc biệt trong chuỗi": "int countSpecialChars(const std::string& str) { return std::count_if(str.begin(), str.end(), [](char c) { return !std::isalnum(c) && !std::isspace(c); }); }",
    "xóa tất cả các ký tự trắng trong chuỗi": "std::string removeWhitespace(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), [](char c) { return !std::isspace(c); }); return result; }",
    "chèn một chuỗi vào giữa một chuỗi khác": "std::string insertString(const std::string& original, const std::string& toInsert, size_t position) { std::string result = original; result.insert(position, toInsert); return result; }",
    "tạo vector từ một chuỗi các số cách nhau bởi dấu phẩy": "std::vector<int> stringToVector(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string temp; while (std::getline(iss, temp, ',')) { vec.push_back(std::stoi(temp)); } return vec; }",
    "kiểm tra mảng có phải là mảng tăng dần không": "bool isSortedAscending(const std::vector<int>& vec) { return std::is_sorted(vec.begin(), vec.end()); }",
    "kiểm tra mảng có phải là mảng giảm dần không": "bool isSortedDescending(const std::vector<int>& vec) { return std::is_sorted(vec.rbegin(), vec.rend()); }",
    "tính trung bình của các phần tử trong ma trận": "double averageMatrix(const std::vector<std::vector<int>>& matrix) { double sum = 0; int count = 0; for (const auto& row : matrix) { sum += std::accumulate(row.begin(), row.end(), 0); count += row.size(); } return sum / count; }",
    "hoán đổi hai phần tử trong vector": "void swapElements(std::vector<int>& vec, size_t i, size_t j) { if (i < vec.size() && j < vec.size()) std::swap(vec[i], vec[j]); }",
    "tính số lượng ký tự số trong chuỗi": "int countDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isdigit); }",
    "tạo chuỗi từ các ký tự trong vector": "std::string vectorToString(const std::vector<char>& vec) { return std::string(vec.begin(), vec.end()); }",
    "tìm giá trị lớn nhất trong vector của vector": "int findMaxInVectorOfVectors(const std::vector<std::vector<int>>& matrix) { return *std::max_element(matrix.begin(), matrix.end(), [](const std::vector<int>& a, const std::vector<int>& b) { return *std::max_element(a.begin(), a.end()) < *std::max_element(b.begin(), b.end()); }); }",
    "xóa phần tử đầu tiên trong vector": "void removeFirstElement(std::vector<int>& vec) { if (!vec.empty()) vec.erase(vec.begin()); }",
    "xóa phần tử cuối cùng trong vector": "void removeLastElement(std::vector<int>& vec) { if (!vec.empty()) vec.pop_back(); }",
    "lấy tất cả các ký tự chữ cái từ chuỗi": "std::string getAlphabeticChars(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), ::isalpha); return result; }",
    "đảo ngược chuỗi": "std::string reverseString(const std::string& str) { return std::string(str.rbegin(), str.rend()); }",
    "kiểm tra nếu một vector có số lượng phần tử chẵn": "bool hasEvenSize(const std::vector<int>& vec) { return vec.size() % 2 == 0; }",
    "chuyển đổi vector thành chuỗi với phần tử cách nhau bởi dấu cách": "std::string vectorToStringWithSpaces(const std::vector<int>& vec) { std::ostringstream oss; std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(oss, \" \")); return oss.str(); }",
    "tìm số chính phương lớn nhất trong vector": "int maxPerfectSquare(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end(), [](int a, int b) { return !isPerfectSquare(a) || (isPerfectSquare(b) && b > a); }); }",
    "tính tổng tất cả các số lẻ trong vector": "int sumOdd(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { return num % 2 != 0 ? sum + num : sum; }); }",
    "kiểm tra chuỗi có chứa ký tự đặc biệt không": "bool containsSpecialChar(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char c) { return !std::isalnum(c) && !std::isspace(c); }); }",
    "tính số lượng từ trong chuỗi": "int wordCount(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "tạo ma trận vuông với giá trị khởi tạo": "std::vector<std::vector<int>> createMatrix(int size, int value) { return std::vector<std::vector<int>>(size, std::vector<int>(size, value)); }",
    "chèn phần tử vào đầu của vector": "void insertAtBeginning(std::vector<int>& vec, int value) { vec.insert(vec.begin(), value); }",
    "tìm kiếm chuỗi con trong chuỗi": "bool containsSubstring(const std::string& str, const std::string& substr) { return str.find(substr) != std::string::npos; }",
    "đếm số lần xuất hiện của một ký tự trong chuỗi": "int countCharOccurrences(const std::string& str, char ch) { return std::count(str.begin(), str.end(), ch); }",
    "tạo vector từ một chuỗi các số cách nhau bởi dấu cách": "std::vector<int> spaceSeparatedStringToVector(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); int temp; while (iss >> temp) { vec.push_back(temp); } return vec; }",
    "kiểm tra chuỗi có phải là số nguyên không": "bool isInteger(const std::string& str) { return !str.empty() && std::all_of(str.begin(), str.end(), ::isdigit); }",
    "xóa tất cả các ký tự không phải số trong chuỗi": "std::string removeNonDigits(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), ::isdigit); return result; }",
    "tính tích của tất cả các phần tử trong vector": "int productOfElements(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>()); }",
    "kiểm tra một số có phải là số hoàn hảo không": "bool isPerfectNumber(int num) { if (num < 1) return false; int sum = 0; for (int i = 1; i <= num / 2; ++i) { if (num % i == 0) sum += i; } return sum == num; }",
    "tạo chuỗi từ một vector các số nguyên cách nhau bởi dấu phẩy": "std::string vectorToCommaSeparatedString(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << \",\"; oss << vec[i]; } return oss.str(); }",
    "tính tổng các số chẵn trong vector": "int sumEven(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { return num % 2 == 0 ? sum + num : sum; }); }",
    "kiểm tra vector có phải là chuỗi giảm dần không": "bool isDecreasing(const std::vector<int>& vec) { return std::is_sorted(vec.rbegin(), vec.rend()); }",
    "tạo một chuỗi với số lượng ký tự cụ thể": "std::string createString(char ch, size_t count) { return std::string(count, ch); }",
    "tính tổng của tất cả các số nguyên trong chuỗi": "int sumIntegersInString(const std::string& str) { std::istringstream iss(str); int num, sum = 0; while (iss >> num) { sum += num; } return sum; }",
    "tìm số nguyên tố nhỏ nhất lớn hơn hoặc bằng n": "int nextPrime(int n) { while (true) { bool isPrime = true; if (n <= 1) isPrime = false; for (int i = 2; i <= sqrt(n); ++i) { if (n % i == 0) { isPrime = false; break; } } if (isPrime) return n; ++n; } }",
    "sắp xếp vector theo thứ tự giảm dần": "void sortDescending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end(), std::greater<int>()); }",
    "tạo vector với số lượng phần tử cụ thể và giá trị khởi tạo": "std::vector<int> createVector(size_t size, int value) { return std::vector<int>(size, value); }",
    "tìm số nguyên tố nhỏ hơn hoặc bằng n": "std::vector<int> primesUpTo(int n) { std::vector<int> primes; std::vector<bool> isPrime(n + 1, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i <= n; ++i) { if (isPrime[i]) { primes.push_back(i); for (int j = i * i; j <= n; j += i) isPrime[j] = false; } } return primes; }",
    "tìm số Fibonacci thứ n (phiên bản động)": "int fibonacci(int n) { if (n <= 1) return n; std::vector<int> fib(n + 1); fib[0] = 0; fib[1] = 1; for (int i = 2; i <= n; ++i) { fib[i] = fib[i - 1] + fib[i - 2]; } return fib[n]; }",
    "tìm ước số chung lớn nhất (UCLN) của hai số": "int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; }",
    "tìm bội số chung nhỏ nhất (BCNN) của hai số": "int lcm(int a, int b) { return a * b / gcd(a, b); }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimes(int n) { int sum = 0; for (int num = 2; num < n; ++num) { bool isPrime = true; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) sum += num; } return sum; }",
    "tìm kiếm nhị phân trong mảng": "int binarySearch(const std::vector<int>& arr, int target) { int left = 0, right = arr.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",
    "sắp xếp mảng bằng thuật toán sắp xếp nổi bọt (Bubble Sort)": "void bubbleSort(std::vector<int>& arr) { for (size_t i = 0; i < arr.size() - 1; ++i) { for (size_t j = 0; j < arr.size() - i - 1; ++j) { if (arr[j] > arr[j + 1]) std::swap(arr[j], arr[j + 1]); } } }",
    "sắp xếp mảng bằng thuật toán sắp xếp chọn (Selection Sort)": "void selectionSort(std::vector<int>& arr) { for (size_t i = 0; i < arr.size(); ++i) { size_t minIndex = i; for (size_t j = i + 1; j < arr.size(); ++j) { if (arr[j] < arr[minIndex]) minIndex = j; } std::swap(arr[i], arr[minIndex]); } }",
    "tính trung bình của mảng": "double average(const std::vector<int>& arr) { int sum = 0; for (int num : arr) sum += num; return static_cast<double>(sum) / arr.size(); }",
    "tính số lượng phần tử trong mảng lớn hơn x": "int countGreaterThan(const std::vector<int>& arr, int x) { return std::count_if(arr.begin(), arr.end(), [x](int num) { return num > x; }); }",
    "tính số lượng phần tử trong mảng nhỏ hơn x": "int countLessThan(const std::vector<int>& arr, int x) { return std::count_if(arr.begin(), arr.end(), [x](int num) { return num < x; }); }",
    "tính tổng các phần tử trong mảng": "int sum(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0); }",
    "tính số lượng số nguyên tố trong mảng": "int countPrimes(const std::vector<int>& arr) { int count = 0; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i <= sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) ++count; } return count; }",
    "kiểm tra chuỗi có phải là palindrome không": "bool isPalindrome(const std::string& str) { int left = 0, right = str.size() - 1; while (left < right) { if (str[left++] != str[right--]) return false; } return true; }",
    "tìm số lớn thứ hai trong mảng": "int secondLargest(const std::vector<int>& arr) { int largest = INT_MIN, second = INT_MIN; for (int num : arr) { if (num > largest) { second = largest; largest = num; } else if (num > second && num < largest) { second = num; } } return second; }",
    "tìm số chính phương lớn nhất nhỏ hơn n": "int largestPerfectSquare(int n) { int root = std::sqrt(n - 1); return root * root; }",
    "tính phương sai của mảng": "double variance(const std::vector<int>& arr) { double avg = average(arr); double sum = 0; for (int num : arr) { double diff = num - avg; sum += diff * diff; } return sum / arr.size(); }",
    "tính tích các phần tử trong vector": "int product(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>()); }",
    "tìm kiếm tuyến tính trong vector": "int linearSearch(const std::vector<int>& vec, int target) { for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] == target) return i; } return -1; }",
    "tính số lượng số chẵn trong mảng": "int countEven(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 == 0; }); }",
    "tính số lượng số lẻ trong mảng": "int countOdd(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 != 0; }); }",
    "tìm số nhỏ nhất trong mảng": "int findMin(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end()); }",
    "tìm số lớn nhất trong mảng": "int findMax(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tính số lượng phần tử xuất hiện nhiều nhất trong mảng": "int mostFrequent(const std::vector<int>& arr) { std::unordered_map<int, int> countMap; for (int num : arr) { countMap[num]++; } int maxCount = 0, result = arr[0]; for (const auto& pair : countMap) { if (pair.second > maxCount) { maxCount = pair.second; result = pair.first; } } return result; }",
    "tìm số nguyên tố lớn nhất nhỏ hơn n": "int largestPrimeLessThan(int n) { for (int i = n - 1; i >= 2; --i) { bool isPrime = true; for (int j = 2; j * j <= i; ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) return i; } return -1; }",
    "kiểm tra số chính phương": "bool isPerfectSquare(int x) { int s = std::sqrt(x); return s * s == x; }",
    "tính tổng các số chính phương nhỏ hơn n": "int sumPerfectSquares(int n) { int sum = 0; for (int i = 1; i * i < n; ++i) { sum += i * i; } return sum; }",
    "tính số lượng các số nguyên tố trong dãy số từ 1 đến n": "int countPrimesUpTo(int n) { std::vector<bool> isPrime(n + 1, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i <= n; ++i) { if (isPrime[i]) { for (int j = i * i; j <= n; j += i) isPrime[j] = false; } } return std::count(isPrime.begin(), isPrime.end(), true); }",
    "sắp xếp mảng bằng thuật toán sắp xếp chèn (Insertion Sort)": "void insertionSort(std::vector<int>& arr) { for (size_t i = 1; i < arr.size(); ++i) { int key = arr[i]; int j = i - 1; while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; --j; } arr[j + 1] = key; } }",
    "sắp xếp mảng bằng thuật toán sắp xếp nhanh (Quick Sort)": "int partition(std::vector<int>& arr, int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; ++j) { if (arr[j] < pivot) { std::swap(arr[++i], arr[j]); } } std::swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(std::vector<int>& arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } }",
    "sắp xếp mảng bằng thuật toán sắp xếp trộn (Merge Sort)": "void merge(std::vector<int>& arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; std::vector<int> L(n1), R(n2); for (int i = 0; i < n1; ++i) L[i] = arr[left + i]; for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j]; int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; } void mergeSort(std::vector<int>& arr, int left, int right) { if (left < right) { int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } }",
    "tính số lượng số nguyên tố trong mảng với số lượng phần tử ít hơn x": "int countPrimesLessThan(const std::vector<int>& arr, int x) { return std::count_if(arr.begin(), arr.end(), [x](int num) { if (num < x) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } return isPrime; } return false; }); }",
    "tính số lượng số nguyên tố lớn hơn x": "int countPrimesGreaterThan(const std::vector<int>& arr, int x) { return std::count_if(arr.begin(), arr.end(), [x](int num) { if (num > x) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } return isPrime; } return false; }); }",
    "tính tổng các số nguyên trong mảng chia hết cho x": "int sumDivisibleBy(const std::vector<int>& arr, int x) { int sum = 0; for (int num : arr) { if (num % x == 0) sum += num; } return sum; }",
    "kiểm tra mảng đã sắp xếp chưa": "bool isSorted(const std::vector<int>& arr) { for (size_t i = 1; i < arr.size(); ++i) { if (arr[i - 1] > arr[i]) return false; } return true; }",
    "tính trung bình cộng của các số nguyên tố trong mảng": "double averagePrimes(const std::vector<int>& arr) { int sum = 0, count = 0; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) { sum += num; ++count; } } return count > 0 ? static_cast<double>(sum) / count : 0; }",
    "tìm số nhỏ nhất trong mảng với điều kiện là số nguyên tố": "int minPrime(const std::vector<int>& arr) { int minPrime = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num < minPrime) minPrime = num; } return minPrime == INT_MAX ? -1 : minPrime; }",
    "tìm số lớn nhất trong mảng với điều kiện là số chính phương": "int maxPerfectSquare(const std::vector<int>& arr) { int maxSquare = INT_MIN; for (int num : arr) { if (isPerfectSquare(num) && num > maxSquare) maxSquare = num; } return maxSquare == INT_MIN ? -1 : maxSquare; }",
    "tìm số nguyên tố nhỏ nhất trong mảng": "int minPrimeInArray(const std::vector<int>& arr) { int minPrime = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num < minPrime) minPrime = num; } return minPrime == INT_MAX ? -1 : minPrime; }",
    "tính số lượng số lẻ trong mảng": "int countOddNumbers(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 != 0; }); }",
    "tính số lượng số chẵn trong mảng": "int countEvenNumbers(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 == 0; }); }",
    "tính tổng các số nguyên dương trong mảng": "int sumPositiveNumbers(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num > 0 ? sum + num : sum; }); }",
    "tìm số nhỏ nhất trong mảng không âm": "int minNonNegative(const std::vector<int>& arr) { int minNum = INT_MAX; for (int num : arr) { if (num >= 0 && num < minNum) minNum = num; } return minNum == INT_MAX ? -1 : minNum; }",
    "tìm số lớn nhất trong mảng không âm": "int maxNonNegative(const std::vector<int>& arr) { int maxNum = INT_MIN; for (int num : arr) { if (num >= 0 && num > maxNum) maxNum = num; } return maxNum == INT_MIN ? -1 : maxNum; }",
    "tìm phần tử đầu tiên lớn hơn x trong mảng": "int findFirstGreaterThan(const std::vector<int>& arr, int x) { auto it = std::find_if(arr.begin(), arr.end(), [x](int num) { return num > x; }); return it != arr.end() ? *it : -1; }",
    "tìm phần tử cuối cùng nhỏ hơn x trong mảng": "int findLastLessThan(const std::vector<int>& arr, int x) { auto it = std::find_if(arr.rbegin(), arr.rend(), [x](int num) { return num < x; }); return it != arr.rend() ? *it : -1; }",
    "tìm số chính phương lớn nhất trong mảng không âm": "int maxPerfectSquareNonNegative(const std::vector<int>& arr) { int maxSquare = INT_MIN; for (int num : arr) { if (num >= 0 && isPerfectSquare(num) && num > maxSquare) maxSquare = num; } return maxSquare == INT_MIN ? -1 : maxSquare; }",
    "tính số lượng số chính phương trong mảng": "int countPerfectSquares(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return isPerfectSquare(num); }); }",
    "kiểm tra xem mảng có chứa số nguyên tố không": "bool containsPrime(const std::vector<int>& arr) { return std::any_of(arr.begin(), arr.end(), [](int num) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } return isPrime; }); }",
    "tìm số nhỏ nhất trong mảng có số lượng chữ số chẵn": "int minEvenDigitNumber(const std::vector<int>& arr) { int minNum = INT_MAX; for (int num : arr) { int digitCount = std::to_string(num).length(); if (digitCount % 2 == 0 && num < minNum) minNum = num; } return minNum == INT_MAX ? -1 : minNum; }",
    "tính số lượng phần tử trong mảng lớn hơn hoặc bằng x và nhỏ hơn hoặc bằng y": "int countInRange(const std::vector<int>& arr, int x, int y) { return std::count_if(arr.begin(), arr.end(), [x, y](int num) { return num >= x && num <= y; }); }",
    "tìm số lẻ lớn nhất trong mảng": "int maxOddNumber(const std::vector<int>& arr) { int maxOdd = INT_MIN; for (int num : arr) { if (num % 2 != 0 && num > maxOdd) maxOdd = num; } return maxOdd == INT_MIN ? -1 : maxOdd; }",
    "tìm số chẵn nhỏ nhất trong mảng": "int minEvenNumber(const std::vector<int>& arr) { int minEven = INT_MAX; for (int num : arr) { if (num % 2 == 0 && num < minEven) minEven = num; } return minEven == INT_MAX ? -1 : minEven; }",
    "tính tổng các số âm trong mảng": "int sumNegativeNumbers(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num < 0 ? sum + num : sum; }); }",
    "tìm số nhỏ nhất trong mảng lớn hơn x và nhỏ hơn y": "int minInRange(const std::vector<int>& arr, int x, int y) { int minNum = INT_MAX; for (int num : arr) { if (num > x && num < y && num < minNum) minNum = num; } return minNum == INT_MAX ? -1 : minNum; }",
    "tìm số lớn nhất trong mảng nhỏ hơn x và lớn hơn y": "int maxInRange(const std::vector<int>& arr, int x, int y) { int maxNum = INT_MIN; for (int num : arr) { if (num < x && num > y && num > maxNum) maxNum = num; } return maxNum == INT_MIN ? -1 : maxNum; }",
    "tính tổng các số nguyên tố nhỏ hơn x trong mảng": "int sumPrimesLessThan(const std::vector<int>& arr, int x) { return std::accumulate(arr.begin(), arr.end(), 0, [x](int sum, int num) { if (num < x) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } return isPrime ? sum + num : sum; } return sum; }); }",
    "tìm số lớn nhất nhỏ hơn x trong mảng": "int findMaxLessThan(const std::vector<int>& arr, int x) { int maxNum = INT_MIN; for (int num : arr) { if (num < x && num > maxNum) maxNum = num; } return maxNum == INT_MIN ? -1 : maxNum; }",
    "tính tổng các phần tử chẵn trong mảng": "int sumEvenNumbers(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 == 0 ? sum + num : sum; }); }",
    "tính tổng các phần tử lẻ trong mảng": "int sumOddNumbers(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 != 0 ? sum + num : sum; }); }",
    "tìm số nguyên tố nhỏ nhất trong mảng": "int minPrimeNumber(const std::vector<int>& arr) { int minPrime = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num < minPrime) minPrime = num; } return minPrime == INT_MAX ? -1 : minPrime; }",
    "tìm số nguyên tố lớn nhất trong mảng": "int maxPrimeNumber(const std::vector<int>& arr) { int maxPrime = INT_MIN; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num > maxPrime) maxPrime = num; } return maxPrime == INT_MIN ? -1 : maxPrime; }",
    "tìm số chính phương nhỏ nhất trong mảng": "int minPerfectSquare(const std::vector<int>& arr) { int minSquare = INT_MAX; for (int num : arr) { if (isPerfectSquare(num) && num < minSquare) minSquare = num; } return minSquare == INT_MAX ? -1 : minSquare; }",
    "tính tổng các số chính phương trong mảng": "int sumPerfectSquares(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return isPerfectSquare(num) ? sum + num : sum; }); }",
    "kiểm tra mảng có chứa số chẵn không": "bool containsEven(const std::vector<int>& arr) { return std::any_of(arr.begin(), arr.end(), [](int num) { return num % 2 == 0; }); }",
    "kiểm tra mảng có chứa số lẻ không": "bool containsOdd(const std::vector<int>& arr) { return std::any_of(arr.begin(), arr.end(), [](int num) { return num % 2 != 0; }); }",
    "tìm số nguyên tố nhỏ nhất lớn hơn x trong mảng": "int findSmallestPrimeGreaterThan(const std::vector<int>& arr, int x) { int minPrime = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num > x && num < minPrime) minPrime = num; } return minPrime == INT_MAX ? -1 : minPrime; }",
    "tính trung bình các số dương trong mảng": "double averagePositiveNumbers(const std::vector<int>& arr) { int sum = 0, count = 0; for (int num : arr) { if (num > 0) { sum += num; ++count; } } return count > 0 ? static_cast<double>(sum) / count : 0.0; }",
    "tìm số chẵn lớn nhất trong mảng không âm": "int maxEvenNumberNonNegative(const std::vector<int>& arr) { int maxEven = INT_MIN; for (int num : arr) { if (num >= 0 && num % 2 == 0 && num > maxEven) maxEven = num; } return maxEven == INT_MIN ? -1 : maxEven; }",
    "tìm số lẻ nhỏ nhất trong mảng không âm": "int minOddNumberNonNegative(const std::vector<int>& arr) { int minOdd = INT_MAX; for (int num : arr) { if (num >= 0 && num % 2 != 0 && num < minOdd) minOdd = num; } return minOdd == INT_MAX ? -1 : minOdd; }",
    "tính số lượng phần tử lớn hơn giá trị trung bình trong mảng": "int countAboveAverage(const std::vector<int>& arr) { double avg = average(arr); return std::count_if(arr.begin(), arr.end(), [avg](int num) { return num > avg; }); }",
    "tính số lượng phần tử nhỏ hơn giá trị trung bình trong mảng": "int countBelowAverage(const std::vector<int>& arr) { double avg = average(arr); return std::count_if(arr.begin(), arr.end(), [avg](int num) { return num < avg; }); }",
    "tìm số nguyên tố lớn nhất nhỏ hơn x trong mảng": "int findLargestPrimeLessThan(const std::vector<int>& arr, int x) { int maxPrime = INT_MIN; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num < x && num > maxPrime) maxPrime = num; } return maxPrime == INT_MIN ? -1 : maxPrime; }",
    "tìm số nguyên tố gần nhất với x trong mảng": "int findClosestPrime(const std::vector<int>& arr, int x) { int closest = INT_MAX; int minDiff = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } int diff = abs(num - x); if (isPrime && diff < minDiff) { closest = num; minDiff = diff; } } return closest == INT_MAX ? -1 : closest; }",
    "tính tổng các số chính phương nhỏ hơn x": "int sumPerfectSquaresLessThanX(const std::vector<int>& arr, int x) { return std::accumulate(arr.begin(), arr.end(), 0, [x](int sum, int num) { return num < x && isPerfectSquare(num) ? sum + num : sum; }); }",
    "kiểm tra mảng có chứa số chính phương không": "bool containsPerfectSquare(const std::vector<int>& arr) { return std::any_of(arr.begin(), arr.end(), [](int num) { return isPerfectSquare(num); }); }",
    "tìm số nhỏ nhất có số chữ số bằng k trong mảng": "int findSmallestNumberWithKDigits(const std::vector<int>& arr, int k) { int minNumber = INT_MAX; for (int num : arr) { if (num >= pow(10, k - 1) && num < pow(10, k)) { minNumber = std::min(minNumber, num); } } return minNumber == INT_MAX ? -1 : minNumber; }",
    "tìm số lớn nhất có số chữ số bằng k trong mảng": "int findLargestNumberWithKDigits(const std::vector<int>& arr, int k) { int maxNumber = INT_MIN; for (int num : arr) { if (num >= pow(10, k - 1) && num < pow(10, k)) { maxNumber = std::max(maxNumber, num); } } return maxNumber == INT_MIN ? -1 : maxNumber; }",
    "tính số lượng phần tử chính phương trong mảng": "int countPerfectSquares(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return isPerfectSquare(num); }); }",
    "tìm số nguyên tố gần nhất với giá trị trung bình của mảng": "int findClosestPrimeToAverage(const std::vector<int>& arr) { double avg = average(arr); int closest = INT_MAX; int minDiff = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } int diff = abs(num - avg); if (isPrime && diff < minDiff) { closest = num; minDiff = diff; } } return closest == INT_MAX ? -1 : closest; }",
    "tìm số nguyên tố lớn nhất trong mảng mà không phải là số chính phương": "int maxPrimeNotPerfectSquare(const std::vector<int>& arr) { int maxPrime = INT_MIN; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && !isPerfectSquare(num) && num > maxPrime) maxPrime = num; } return maxPrime == INT_MIN ? -1 : maxPrime; }",
    "tính tổng các số nguyên tố trong mảng mà không phải là số chính phương": "int sumPrimesNotPerfectSquare(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } return isPrime && !isPerfectSquare(num) ? sum + num : sum; }); }",
    "tìm số nguyên tố nhỏ nhất lớn hơn hoặc bằng x trong mảng": "int findSmallestPrimeGreaterOrEqual(const std::vector<int>& arr, int x) { int minPrime = INT_MAX; for (int num : arr) { bool isPrime = num > 1; for (int i = 2; i * i <= num; ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num >= x && num < minPrime) minPrime = num; } return minPrime == INT_MAX ? -1 : minPrime; }",
    "tính số lượng phần tử chính phương lớn hơn x trong mảng": "int countPerfectSquaresGreaterThanX(const std::vector<int>& arr, int x) { return std::count_if(arr.begin(), arr.end(), [x](int num) { return num > x && isPerfectSquare(num); }); }",
    "tính tổng các phần tử âm trong mảng": "int sumNegative(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num < 0 ? sum + num : sum; }); }",
    "tính tổng các phần tử dương trong mảng": "int sumPositive(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num > 0 ? sum + num : sum; }); }",
    "tìm số lớn nhất trong mảng và trả về vị trí của nó": "int findMaxPosition(const std::vector<int>& arr) { return std::distance(arr.begin(), std::max_element(arr.begin(), arr.end())); }",
    "tìm số nhỏ nhất trong mảng và trả về vị trí của nó": "int findMinPosition(const std::vector<int>& arr) { return std::distance(arr.begin(), std::min_element(arr.begin(), arr.end())); }",
    "tính tổng bình phương các số trong mảng": "int sumOfSquares(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return sum + num * num; }); }",
    "tính tổng các số chia hết cho k trong mảng": "int sumDivisibleByK(const std::vector<int>& arr, int k) { return std::accumulate(arr.begin(), arr.end(), 0, [k](int sum, int num) { return num % k == 0 ? sum + num : sum; }); }",
    "tính tổng các số không chia hết cho k trong mảng": "int sumNotDivisibleByK(const std::vector<int>& arr, int k) { return std::accumulate(arr.begin(), arr.end(), 0, [k](int sum, int num) { return num % k != 0 ? sum + num : sum; }); }",
    "tìm số lẻ lớn nhất trong mảng": "int findLargestOdd(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return a % 2 == 0 || (b % 2 != 0 && a < b); }); }",
    "tìm số chẵn nhỏ nhất trong mảng": "int findSmallestEven(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end(), [](int a, int b) { return a % 2 != 0 || (b % 2 == 0 && a > b); }); }",
    "sắp xếp mảng theo thứ tự tăng dần": "void sortAscending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end()); }",
    "sắp xếp mảng theo thứ tự giảm dần": "void sortDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "tính tổng các số lẻ trong mảng": "int sumOdds(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 != 0 ? sum + num : sum; }); }",
    "tính tổng các số chẵn trong mảng": "int sumEvens(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num % 2 == 0 ? sum + num : sum; }); }",
    "tìm số có số lượng chữ số lẻ lớn nhất trong mảng": "int findNumberWithMostOddDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return countOddDigits(a) < countOddDigits(b); }); }",
    "tính số lượng số lẻ có mặt trong mảng": "int countOddNumbers(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 != 0; }); }",
    "tính số lượng số chẵn có mặt trong mảng": "int countEvenNumbers(const std::vector<int>& arr) { return std::count_if(arr.begin(), arr.end(), [](int num) { return num % 2 == 0; }); }",
    "tìm số có số lượng chữ số chẵn lớn nhất trong mảng": "int findNumberWithMostEvenDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return countEvenDigits(a) < countEvenDigits(b); }); }",
    "tính tổng các số âm có số lượng chữ số lẻ trong mảng": "int sumNegativeWithOddDigits(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num < 0 && countOddDigits(num) % 2 != 0 ? sum + num : sum; }); }",
    "tìm số âm lớn nhất có số lượng chữ số chẵn trong mảng": "int findLargestNegativeWithEvenDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return a < 0 && countEvenDigits(a) < countEvenDigits(b); }); }",
    "tính tổng các số chính phương trong mảng": "int sumPerfectSquares(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { int sqrtNum = static_cast<int>(std::sqrt(num)); return sqrtNum * sqrtNum == num ? sum + num : sum; }); }",
    "tìm số chính phương lớn nhất trong mảng": "int findLargestPerfectSquare(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return !isPerfectSquare(a) || (isPerfectSquare(b) && a < b); }); }",
    "tìm số chính phương nhỏ nhất trong mảng": "int findSmallestPerfectSquare(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end(), [](int a, int b) { return !isPerfectSquare(a) || (isPerfectSquare(b) && a > b); }); }",
    "tính tổng các số nguyên tố nhỏ hơn n": "int sumPrimesBelowN(int n) { int sum = 0; for (int i = 2; i < n; ++i) { bool isPrime = true; for (int j = 2; j <= std::sqrt(i); ++j) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) sum += i; } return sum; }",
    "tìm số nguyên tố nhỏ nhất lớn hơn n": "int findSmallestPrimeGreaterThanN(int n) { int num = n + 1; while (true) { bool isPrime = true; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) return num; ++num; } }",
    "tìm số nguyên tố lớn nhất nhỏ hơn n": "int findLargestPrimeLessThanN(int n) { for (int num = n - 1; num >= 2; --num) { bool isPrime = true; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) return num; } return -1; }",
    "tính tổng các số trong mảng chia hết cho k": "int sumDivisibleByK(const std::vector<int>& arr, int k) { return std::accumulate(arr.begin(), arr.end(), 0, [k](int sum, int num) { return num % k == 0 ? sum + num : sum; }); }",
    "tính tổng các số trong mảng không chia hết cho k": "int sumNotDivisibleByK(const std::vector<int>& arr, int k) { return std::accumulate(arr.begin(), arr.end(), 0, [k](int sum, int num) { return num % k != 0 ? sum + num : sum; }); }",
    "tìm số lớn nhất có số lượng chữ số lớn nhất trong mảng": "int findLargestNumberWithMostDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return std::to_string(a).size() < std::to_string(b).size(); }); }",
    "tìm số nhỏ nhất có số lượng chữ số nhỏ nhất trong mảng": "int findSmallestNumberWithFewestDigits(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end(), [](int a, int b) { return std::to_string(a).size() > std::to_string(b).size(); }); }",
    "tìm số nguyên tố có số lượng chữ số nhỏ nhất trong mảng": "int findSmallestPrimeWithFewestDigits(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end(), [](int a, int b) { return isPrime(a) && (std::to_string(a).size() < std::to_string(b).size()); }); }",
    "tìm số nguyên tố lớn nhất có số lượng chữ số lớn nhất trong mảng": "int findLargestPrimeWithMostDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return isPrime(a) && (std::to_string(a).size() < std::to_string(b).size()); }); }",
    "tính tổng các số dương có số lượng chữ số lẻ trong mảng": "int sumPositiveWithOddDigits(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0, [](int sum, int num) { return num > 0 && countOddDigits(num) % 2 != 0 ? sum + num : sum; }); }",
    "tìm số dương lớn nhất có số lượng chữ số lẻ trong mảng": "int findLargestPositiveWithOddDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return a > 0 && countOddDigits(a) < countOddDigits(b); }); }",
    "tìm số âm lớn nhất có số lượng chữ số lẻ trong mảng": "int findLargestNegativeWithOddDigits(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end(), [](int a, int b) { return a < 0 && countOddDigits(a) < countOddDigits(b); }); }",
    "tính tổng các số nguyên có chữ số lớn nhất trong mảng": "int sumNumbersWithMaxDigits(const std::vector<int>& arr) { int maxDigits = std::max_element(arr.begin(), arr.end(), [](int a, int b) { return std::to_string(a).size() < std::to_string(b).size(); }); return std::accumulate(arr.begin(), arr.end(), 0, [maxDigits](int sum, int num) { return std::to_string(num).size() == maxDigits ? sum + num : sum; }); }",
    "tính giá trị tuyệt đối của số nguyên": "int absValue(int x) { return std::abs(x); }",
    "tính giá trị tuyệt đối của số thực": "double absValue(double x) { return std::abs(x); }",
    "tìm giá trị lớn nhất trong mảng": "int maxElement(const std::vector<int>& arr) { return *std::max_element(arr.begin(), arr.end()); }",
    "tìm giá trị nhỏ nhất trong mảng": "int minElement(const std::vector<int>& arr) { return *std::min_element(arr.begin(), arr.end()); }",
    "sắp xếp mảng tăng dần": "void sortArray(std::vector<int>& arr) { std::sort(arr.begin(), arr.end()); }",
    "sắp xếp mảng giảm dần": "void sortArrayDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "tạo số ngẫu nhiên trong khoảng từ 0 đến n": "int randomNumber(int n) { return std::rand() % (n + 1); }",
    "tạo số ngẫu nhiên trong khoảng từ a đến b": "int randomRange(int a, int b) { return a + std::rand() % (b - a + 1); }",
    "tìm số nguyên tố trong khoảng từ a đến b": "std::vector<int> primesInRange(int a, int b) { std::vector<int> primes; for (int num = a; num <= b; ++num) { bool isPrime = num > 1; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(num); } return primes; }",
    "tính căn bậc hai của số thực": "double squareRoot(double x) { return std::sqrt(x); }",
    "tính lũy thừa của số thực": "double power(double base, double exp) { return std::pow(base, exp); }",
    "tính logarit của số thực": "double logarithm(double x) { return std::log(x); }",
    "tính sin của góc (đơn vị radian)": "double sine(double angle) { return std::sin(angle); }",
    "tính cos của góc (đơn vị radian)": "double cosine(double angle) { return std::cos(angle); }",
    "tính tan của góc (đơn vị radian)": "double tangent(double angle) { return std::tan(angle); }",
    "đọc một chuỗi từ đầu vào người dùng": "std::string readString() { std::string input; std::getline(std::cin, input); return input; }",
    "đọc một số nguyên từ đầu vào người dùng": "int readInt() { int input; std::cin >> input; return input; }",
    "đọc một số thực từ đầu vào người dùng": "double readDouble() { double input; std::cin >> input; return input; }",
    "đưa ra thông báo lỗi": "void printError(const std::string& msg) { std::cerr << 'Error: ' << msg << std::endl; }",
    "đưa ra thông báo thành công": "void printSuccess(const std::string& msg) { std::cout << 'Success: ' << msg << std::endl; }",
    "tạo một chuỗi từ một ký tự và độ dài": "std::string stringFromChar(char c, int length) { return std::string(length, c); }",
    "đếm số lượng ký tự trong chuỗi": "size_t countCharacters(const std::string& str) { return str.size(); }",
    "xóa các khoảng trắng ở đầu và cuối chuỗi": "std::string trimString(const std::string& str) { return std::regex_replace(str, std::regex('^\\s+|\\s+$'), ''); }",
    "tìm kiếm chuỗi con trong chuỗi": "size_t findSubstring(const std::string& str, const std::string& substr) { return str.find(substr); }",
    "chia một chuỗi thành các phần tử dựa trên ký tự phân cách": "std::vector<std::string> splitString(const std::string& str, char delimiter) { std::vector<std::string> tokens; std::stringstream ss(str); std::string item; while (std::getline(ss, item, delimiter)) { tokens.push_back(item); } return tokens; }",
    "chuyển đổi chuỗi thành số nguyên": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "chuyển đổi chuỗi thành số thực": "double stringToDouble(const std::string& str) { return std::stod(str); }",
    "chuyển đổi số nguyên thành chuỗi": "std::string intToString(int num) { return std::to_string(num); }",
    "chuyển đổi số thực thành chuỗi": "std::string doubleToString(double num) { return std::to_string(num); }",
    "đổi chữ hoa thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "đổi chữ thường thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "kiểm tra một ký tự có phải là chữ số không": "bool isDigit(char c) { return std::isdigit(c); }",
    "kiểm tra một ký tự có phải là chữ cái không": "bool isAlpha(char c) { return std::isalpha(c); }",
    "kiểm tra một ký tự có phải là ký tự in hoa không": "bool isUpper(char c) { return std::isupper(c); }",
    "kiểm tra một ký tự có phải là ký tự in thường không": "bool isLower(char c) { return std::islower(c); }",
    "kiểm tra một ký tự có phải là khoảng trắng không": "bool isWhitespace(char c) { return std::isspace(c); }",
    "tạo một mảng chứa các số từ 1 đến n": "std::vector<int> range(int n) { std::vector<int> result(n); std::iota(result.begin(), result.end(), 1); return result; }",
    "đảo ngược mảng": "void reverseArray(std::vector<int>& arr) { std::reverse(arr.begin(), arr.end()); }",
    "trộn hai mảng": "std::vector<int> mergeArrays(const std::vector<int>& arr1, const std::vector<int>& arr2) { std::vector<int> result; result.reserve(arr1.size() + arr2.size()); result.insert(result.end(), arr1.begin(), arr1.end()); result.insert(result.end(), arr2.begin(), arr2.end()); return result; }",
    "lặp qua các phần tử của mảng và thực hiện một hành động": "void forEach(std::vector<int>& arr, const std::function<void(int)>& action) { for (int num : arr) { action(num); } }",
    "tính tổng các số trong mảng": "int sumArray(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 0); }",
    "tính tích các số trong mảng": "int productArray(const std::vector<int>& arr) { return std::accumulate(arr.begin(), arr.end(), 1, std::multiplies<int>()); }",
    "kiểm tra mảng có rỗng không": "bool isEmpty(const std::vector<int>& arr) { return arr.empty(); }",
    "tìm số lượng phần tử bằng giá trị cụ thể trong mảng": "int countOccurrences(const std::vector<int>& arr, int value) { return std::count(arr.begin(), arr.end(), value); }",
    "xóa tất cả các phần tử bằng giá trị cụ thể trong mảng": "void removeAllOccurrences(std::vector<int>& arr, int value) { arr.erase(std::remove(arr.begin(), arr.end(), value), arr.end()); }",
    "tạo một chuỗi từ một danh sách các ký tự": "std::string stringFromChars(const std::vector<char>& chars) { return std::string(chars.begin(), chars.end()); }",
    "chuyển đổi chuỗi thành số thực với độ chính xác": "double stringToDoublePrecision(const std::string& str, int precision) { std::stringstream ss(str); double value; ss >> std::fixed; ss.precision(precision); ss >> value; return value; }",
    "kiểm tra chuỗi có chứa một từ con không": "bool containsSubstring(const std::string& str, const std::string& substring) { return str.find(substring) != std::string::npos; }",
    "tìm vị trí của một từ con trong chuỗi": "size_t findSubstring(const std::string& str, const std::string& substring) { return str.find(substring); }",
    "cắt một phần của chuỗi": "std::string substring(const std::string& str, size_t start, size_t length) { return str.substr(start, length); }",
    "chuyển đổi chữ hoa thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result; std::transform(str.begin(), str.end(), std::back_inserter(result), ::tolower); return result; }",
    "chuyển đổi chữ thường thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result; std::transform(str.begin(), str.end(), std::back_inserter(result), ::toupper); return result; }",
    "kiểm tra một chuỗi có phải là số không": "bool isNumber(const std::string& str) { return !str.empty() && std::all_of(str.begin(), str.end(), ::isdigit); }",
    "tìm tất cả các chỉ số của một ký tự trong chuỗi": "std::vector<size_t> findAllOccurrences(const std::string& str, char ch) { std::vector<size_t> indices; for (size_t i = 0; i < str.size(); ++i) { if (str[i] == ch) indices.push_back(i); } return indices; }",
    "tính tổng các giá trị trong một mảng số thực": "double sumArray(const std::vector<double>& arr) { return std::accumulate(arr.begin(), arr.end(), 0.0); }",
    "xóa tất cả các phần tử trùng lặp trong vector": "void removeDuplicates(std::vector<int>& arr) { std::sort(arr.begin(), arr.end()); auto last = std::unique(arr.begin(), arr.end()); arr.erase(last, arr.end()); }",
    "tìm chỉ số của phần tử đầu tiên lớn hơn một giá trị cho trước": "size_t findFirstGreaterThan(const std::vector<int>& arr, int value) { auto it = std::find_if(arr.begin(), arr.end(), [value](int num) { return num > value; }); return it != arr.end() ? std::distance(arr.begin(), it) : arr.size(); }",
    "tính giai thừa của một số nguyên không âm": "unsigned long long factorial(int n) { if (n == 0 || n == 1) return 1; return n * factorial(n - 1); }",
    "kiểm tra một chuỗi có phải là số thực không": "bool isFloat(const std::string& str) { std::istringstream iss(str); float f; return (iss >> f) && (iss.eof()); }",
    "tạo một danh sách liên kết từ một vector": "std::list<int> vectorToList(const std::vector<int>& vec) { return std::list<int>(vec.begin(), vec.end()); }",
    "tạo một vector từ một danh sách liên kết": "std::vector<int> listToVector(const std::list<int>& lst) { return std::vector<int>(lst.begin(), lst.end()); }",
    "sắp xếp một vector theo thứ tự giảm dần": "void sortDescending(std::vector<int>& arr) { std::sort(arr.begin(), arr.end(), std::greater<int>()); }",
    "chèn một chuỗi vào một vị trí cụ thể trong một chuỗi khác": "std::string insertString(std::string str, const std::string& toInsert, size_t position) { str.insert(position, toInsert); return str; }",
    "xóa một ký tự cụ thể trong chuỗi": "std::string removeChar(std::string str, char ch) { str.erase(std::remove(str.begin(), str.end(), ch), str.end()); return str; }",
    "đảo ngược các phần tử trong vector": "void reverseVector(std::vector<int>& arr) { std::reverse(arr.begin(), arr.end()); }",
    "tạo một chuỗi từ các phần tử trong vector, phân tách bằng dấu cách": "std::string joinVector(const std::vector<std::string>& vec) { return std::accumulate(vec.begin(), vec.end(), std::string(), [](const std::string& a, const std::string& b) { return a.empty() ? b : a + ' ' + b; }); }",
    "chuyển đổi số nguyên thành chuỗi với định dạng cụ thể": "std::string intToStringFormatted(int num) { std::ostringstream oss; oss << std::fixed << std::setprecision(2) << num; return oss.str(); }",
    "tạo một danh sách liên kết từ một dãy số": "std::list<int> listFromRange(int start, int end) { std::list<int> result; for (int i = start; i <= end; ++i) result.push_back(i); return result; }",
    "chuyển đổi một chuỗi thành một vector các từ": "std::vector<std::string> splitString(const std::string& str, char delimiter) { std::vector<std::string> result; std::stringstream ss(str); std::string item; while (std::getline(ss, item, delimiter)) result.push_back(item); return result; }",
    "tạo một vector với giá trị từ 0 đến n-1": "std::vector<int> createVector(int n) { std::vector<int> vec(n); std::iota(vec.begin(), vec.end(), 0); return vec; }",
    "tạo một vector với giá trị từ a đến b-1": "std::vector<int> createVectorRange(int a, int b) { std::vector<int> vec(b - a); std::iota(vec.begin(), vec.end(), a); return vec; }",
    "xóa phần tử tại vị trí k trong vector": "void removeAt(std::vector<int>& vec, size_t k) { if (k < vec.size()) vec.erase(vec.begin() + k); }",
    "tạo một map từ hai vector": "std::map<int, std::string> createMap(const std::vector<int>& keys, const std::vector<std::string>& values) { std::map<int, std::string> result; for (size_t i = 0; i < keys.size() && i < values.size(); ++i) result[keys[i]] = values[i]; return result; }",
    "tìm phần tử lớn nhất trong vector": "int findMax(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "tìm phần tử nhỏ nhất trong vector": "int findMin(const std::vector<int>& vec) { return *std::min_element(vec.begin(), vec.end()); }",
    "tạo một vector từ một danh sách liên kết": "std::vector<int> listToVector(const std::list<int>& lst) { return std::vector<int>(lst.begin(), lst.end()); }",
    "tính tổng các phần tử trong một danh sách liên kết": "int sumList(const std::list<int>& lst) { return std::accumulate(lst.begin(), lst.end(), 0); }",
    "sắp xếp một vector theo thứ tự tăng dần": "void sortAscending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end()); }",
    "tìm số nguyên tố trong một vector": "bool isPrime(int num) { if (num < 2) return false; for (int i = 2; i <= sqrt(num); ++i) if (num % i == 0) return false; return true; } std::vector<int> filterPrimes(const std::vector<int>& vec) { std::vector<int> primes; std::copy_if(vec.begin(), vec.end(), std::back_inserter(primes), isPrime); return primes; }",
    "tính tổng của một chuỗi các số nguyên phân cách bởi dấu phẩy": "int sumString(const std::string& str) { std::istringstream iss(str); int sum = 0, num; char delimiter; while (iss >> num) { sum += num; iss >> delimiter; } return sum; }",
    "sắp xếp các chuỗi theo độ dài": "void sortByLength(std::vector<std::string>& vec) { std::sort(vec.begin(), vec.end(), [](const std::string& a, const std::string& b) { return a.size() < b.size(); }); }",
    "tạo một chuỗi từ các số nguyên phân cách bằng dấu gạch ngang": "std::string joinNumbers(const std::vector<int>& nums) { std::ostringstream oss; for (size_t i = 0; i < nums.size(); ++i) { if (i > 0) oss << '-'; oss << nums[i]; } return oss.str(); }",
    "kiểm tra một chuỗi có phải là số nguyên tố không": "bool isPrimeString(const std::string& str) { std::istringstream iss(str); int num; if (!(iss >> num)) return false; return isPrime(num); }",
    "tính tổng các số thực trong một chuỗi phân cách bằng dấu chấm": "double sumFloatString(const std::string& str) { std::istringstream iss(str); double sum = 0.0, num; char delimiter; while (iss >> num) { sum += num; iss >> delimiter; } return sum; }",
    "lặp qua các phần tử trong một vector": "void printVector(const std::vector<int>& vec) { for (const auto& elem : vec) std::cout << elem << ' '; std::cout << std::endl; }",
    "kiểm tra một chuỗi có chứa một từ con không": "bool contains(const std::string& str, const std::string& sub) { return str.find(sub) != std::string::npos; }",
    "thay thế một từ trong chuỗi bằng một từ khác": "std::string replaceWord(std::string str, const std::string& oldWord, const std::string& newWord) { size_t pos = 0; while ((pos = str.find(oldWord, pos)) != std::string::npos) { str.replace(pos, oldWord.length(), newWord); pos += newWord.length(); } return str; }",
    "đọc toàn bộ nội dung của một tệp tin": "std::string readFile(const std::string& filename) { std::ifstream file(filename); std::stringstream buffer; buffer << file.rdbuf(); return buffer.str(); }",
    "ghi nội dung vào một tệp tin": "void writeFile(const std::string& filename, const std::string& content) { std::ofstream file(filename); file << content; }",
    "tạo một mảng động với kích thước n": "int* createArray(int n) { int* arr = new int[n]; std::fill(arr, arr + n, 0); return arr; }",
    "xóa mảng động": "void deleteArray(int* arr) { delete[] arr; }",
    "chuyển đổi chuỗi thành số nguyên": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "chuyển đổi số nguyên thành chuỗi": "std::string intToString(int num) { return std::to_string(num); }",
    "tạo một hàm Lambda để cộng hai số": "auto add = [](int a, int b) { return a + b; };",
    "tính số lượng ký tự trong một chuỗi": "size_t countCharacters(const std::string& str) { return str.size(); }",
    "kiểm tra một chuỗi có phải là số nguyên không": "bool isInteger(const std::string& str) { std::istringstream iss(str); int num; return (iss >> num) && (iss.eof()); }",
    "kiểm tra một chuỗi có phải là số thực không": "bool isFloat(const std::string& str) { std::istringstream iss(str); float num; return (iss >> num) && (iss.eof()); }",
    "sắp xếp một vector theo thứ tự giảm dần": "void sortDescending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end(), std::greater<int>()); }",
    "tạo một chuỗi từ vector các chuỗi phân cách bằng dấu cách": "std::string joinStrings(const std::vector<std::string>& strs) { std::ostringstream oss; for (size_t i = 0; i < strs.size(); ++i) { if (i > 0) oss << ' '; oss << strs[i]; } return oss.str(); }",
    "tính tổng của một mảng số thực": "double sumArray(const double* arr, size_t size) { double sum = 0; for (size_t i = 0; i < size; ++i) sum += arr[i]; return sum; }",
    "tìm kiếm một phần tử trong mảng": "bool containsElement(const int* arr, size_t size, int element) { return std::find(arr, arr + size, element) != arr + size; }",
    "tạo một map từ vector các cặp khóa-giá trị": "std::map<int, std::string> createMapFromPairs(const std::vector<std::pair<int, std::string>>& pairs) { std::map<int, std::string> result; for (const auto& p : pairs) result[p.first] = p.second; return result; }",
    "sắp xếp các phần tử trong một vector theo giá trị tuyệt đối": "void sortByAbsolute(std::vector<int>& vec) { std::sort(vec.begin(), vec.end(), [](int a, int b) { return std::abs(a) < std::abs(b); }); }",
    "tạo một vector từ một chuỗi các số nguyên phân cách bằng dấu phẩy": "std::vector<int> splitStringToVector(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); int num; char delimiter; while (iss >> num) { vec.push_back(num); iss >> delimiter; } return vec; }",
    "tính trung bình của một mảng số thực": "double averageArray(const double* arr, size_t size) { double sum = 0; for (size_t i = 0; i < size; ++i) sum += arr[i]; return sum / size; }",
    "tìm số âm lớn nhất trong một mảng": "int maxNegative(const std::vector<int>& vec) { int maxNeg = INT_MIN; for (int num : vec) { if (num < 0 && num > maxNeg) maxNeg = num; } return maxNeg; }",
    "tìm số dương nhỏ nhất trong một mảng": "int minPositive(const std::vector<int>& vec) { int minPos = INT_MAX; for (int num : vec) { if (num > 0 && num < minPos) minPos = num; } return minPos; }",
    "tạo một chuỗi lặp đi lặp lại nhiều lần": "std::string repeatString(const std::string& str, int count) { std::string result; result.reserve(str.size() * count); for (int i = 0; i < count; ++i) result += str; return result; }",
    "tạo một vector chứa các số nguyên từ 1 đến n": "std::vector<int> createRange(int n) { std::vector<int> range(n); std::iota(range.begin(), range.end(), 1); return range; }",
    "sắp xếp các phần tử trong một vector theo thứ tự tăng dần": "void sortAscending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end()); }",
    "chèn một phần tử vào một vector tại một vị trí cụ thể": "void insertAt(std::vector<int>& vec, size_t pos, int value) { if (pos <= vec.size()) vec.insert(vec.begin() + pos, value); }",
    "tạo một chuỗi từ một vector các ký tự": "std::string vectorToString(const std::vector<char>& vec) { return std::string(vec.begin(), vec.end()); }",
    "tìm tất cả các chỉ số của một giá trị trong vector": "std::vector<size_t> findAllOccurrences(const std::vector<int>& vec, int value) { std::vector<size_t> indices; for (size_t i = 0; i < vec.size(); ++i) if (vec[i] == value) indices.push_back(i); return indices; }",
    "tạo một map từ một vector các số nguyên": "std::map<int, int> createMapFromVector(const std::vector<int>& vec) { std::map<int, int> map; for (int num : vec) ++map[num]; return map; }",
    "tính giá trị trung bình của các phần tử trong một vector số thực": "double mean(const std::vector<double>& vec) { return std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size(); }",
    "tạo một vector các số nguyên từ chuỗi phân cách bằng dấu chấm phẩy": "std::vector<int> splitBySemicolon(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ';')) vec.push_back(std::stoi(item)); return vec; }",
    "lấy phần tử cuối cùng của một vector": "int getLastElement(const std::vector<int>& vec) { return vec.empty() ? -1 : vec.back(); }",
    "tạo một vector từ một danh sách các số nguyên": "std::vector<int> listToVector(const std::initializer_list<int>& list) { return std::vector<int>(list); }",
    "kiểm tra một số có phải là số chính phương không": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "tìm phần tử lớn nhất trong một vector": "int maxElement(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "tính tổng các số nguyên tố trong một vector": "int sumPrimes(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { return isPrime(num) ? sum + num : sum; }); }",
    "tạo một chuỗi ngẫu nhiên với chiều dài nhất định": "std::string randomString(size_t length) { static const std::string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"; std::string str; str.reserve(length); std::generate_n(std::back_inserter(str), length, []() { return chars[rand() % chars.size()]; }); return str; }",
    "kiểm tra một chuỗi có chứa ký tự số không": "bool containsDigit(const std::string& str) { return std::any_of(str.begin(), str.end(), ::isdigit); }",
    "tìm tất cả các phần tử trùng lặp trong một vector": "std::vector<int> findDuplicates(const std::vector<int>& vec) { std::vector<int> duplicates; std::unordered_set<int> seen; for (int num : vec) { if (!seen.insert(num).second) duplicates.push_back(num); } return duplicates; }",
    "lấy tất cả các phần tử chẵn từ một vector": "std::vector<int> getEvenNumbers(const std::vector<int>& vec) { std::vector<int> evenNumbers; std::copy_if(vec.begin(), vec.end(), std::back_inserter(evenNumbers), [](int num) { return num % 2 == 0; }); return evenNumbers; }",
    "chuyển đổi một số nguyên thành nhị phân dưới dạng chuỗi": "std::string toBinary(int num) { std::string binary; while (num > 0) { binary.insert(binary.begin(), '0' + (num % 2)); num /= 2; } return binary.empty() ? \"0\" : binary; }",
    "lấy chỉ số của một phần tử trong một chuỗi": "size_t indexOf(const std::string& str, char ch) { auto pos = str.find(ch); return pos == std::string::npos ? -1 : pos; }",
    "đảo ngược một chuỗi": "std::string reverseString(const std::string& str) { return std::string(str.rbegin(), str.rend()); }",
    "tạo một vector từ một dãy số ngẫu nhiên": "std::vector<int> generateRandomVector(size_t size, int min, int max) { std::vector<int> vec(size); std::generate(vec.begin(), vec.end(), [min, max]() { return rand() % (max - min + 1) + min; }); return vec; }",
    "tạo một vector chứa các số nguyên từ 1 đến n": "std::vector<int> createSequentialVector(int n) { std::vector<int> vec(n); std::iota(vec.begin(), vec.end(), 1); return vec; }",
    "tính tổng của các phần tử trong một vector": "int sumVector(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0); }",
    "tạo một map từ hai vector (key và value)": "std::unordered_map<int, std::string> vectorToMap(const std::vector<int>& keys, const std::vector<std::string>& values) { std::unordered_map<int, std::string> map; for (size_t i = 0; i < keys.size(); ++i) { map[keys[i]] = values[i]; } return map; }",
    "kiểm tra chuỗi có phải là số không": "bool isNumber(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isdigit); }",
    "đọc một số nguyên từ chuỗi": "int stringToInt(const std::string& str) { return std::stoi(str); }",
    "tính tích của các số trong một vector": "int productVector(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>()); }",
    "lấy số nguyên tố nhỏ nhất lớn hơn n": "int nextPrime(int n) { for (int i = n + 1;; ++i) { if (isPrime(i)) return i; } }",
    "tạo một vector từ một chuỗi phân tách bằng dấu phẩy": "std::vector<std::string> splitString(const std::string& str, char delimiter) { std::vector<std::string> tokens; std::stringstream ss(str); std::string token; while (std::getline(ss, token, delimiter)) { tokens.push_back(token); } return tokens; }",
    "chuyển đổi một số nguyên thành chuỗi nhị phân với độ dài cố định": "std::string toBinaryFixed(int num, size_t length) { std::string binary = toBinary(num); binary.insert(binary.begin(), length - binary.size(), '0'); return binary; }",
    "tính số lượng ký tự khác nhau trong một chuỗi": "std::unordered_set<char> uniqueChars(const std::string& str) { return std::unordered_set<char>(str.begin(), str.end()); }",
    "tạo một vector chứa các số nguyên tố nhỏ hơn n": "std::vector<int> primesLessThan(int n) { std::vector<int> primes; for (int i = 2; i < n; ++i) { if (isPrime(i)) primes.push_back(i); } return primes; }",
    "đảo ngược các phần tử của một vector": "void reverseVector(std::vector<int>& vec) { std::reverse(vec.begin(), vec.end()); }",
    "chèn một phần tử vào một vector tại một vị trí cụ thể": "void insertAt(std::vector<int>& vec, int index, int value) { if (index >= 0 && index <= vec.size()) vec.insert(vec.begin() + index, value); }",
    "xoá phần tử khỏi một vector theo giá trị": "void removeValue(std::vector<int>& vec, int value) { vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end()); }",
    "thay thế tất cả các ký tự trong một chuỗi": "std::string replaceAll(std::string str, char oldChar, char newChar) { std::replace(str.begin(), str.end(), oldChar, newChar); return str; }",
    "tìm giá trị nhỏ nhất trong một vector": "int minInVector(const std::vector<int>& vec) { return *std::min_element(vec.begin(), vec.end()); }",
    "sắp xếp một vector theo thứ tự tăng dần": "void sortVectorAscending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end()); }",
    "sắp xếp một vector theo thứ tự giảm dần": "void sortVectorDescending(std::vector<int>& vec) { std::sort(vec.begin(), vec.end(), std::greater<int>()); }",
    "tạo một vector chứa các số từ n đến 1": "std::vector<int> createDescendingVector(int n) { std::vector<int> vec(n); std::iota(vec.rbegin(), vec.rend(), 1); return vec; }",
    "tính tổng của các số trong một vector với điều kiện": "int conditionalSum(const std::vector<int>& vec, std::function<bool(int)> condition) { return std::accumulate(vec.begin(), vec.end(), 0, [&condition](int sum, int value) { return condition(value) ? sum + value : sum; }); }",
    "kiểm tra nếu một vector đã được sắp xếp": "bool isSorted(const std::vector<int>& vec) { return std::is_sorted(vec.begin(), vec.end()); }",
    "tạo một vector từ các ký tự của một chuỗi": "std::vector<char> stringToVector(const std::string& str) { return std::vector<char>(str.begin(), str.end()); }",
    "thay đổi tất cả các ký tự trong chuỗi thành chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "thay đổi tất cả các ký tự trong chuỗi thành chữ thường": "std::string toLowerCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "tạo một vector chứa các số chẵn từ 1 đến n": "std::vector<int> evenNumbers(int n) { std::vector<int> evens; for (int i = 2; i <= n; i += 2) evens.push_back(i); return evens; }",
    "tạo một vector chứa các số lẻ từ 1 đến n": "std::vector<int> oddNumbers(int n) { std::vector<int> odds; for (int i = 1; i <= n; i += 2) odds.push_back(i); return odds; }",
    "tính tổng các phần tử của một vector với một giá trị khởi đầu": "int sumVectorWithInitial(const std::vector<int>& vec, int initial) { return std::accumulate(vec.begin(), vec.end(), initial); }",
    "kiểm tra chuỗi có phải là số thập phân không": "bool isDecimal(const std::string& str) { std::istringstream iss(str); double d; char c; return !(iss >> d).fail() && !(iss >> c).fail(); }",
    "tạo một vector từ các số nguyên tố nhỏ hơn n": "std::vector<int> primesLessThan(int n) { std::vector<int> primes; for (int i = 2; i < n; ++i) { if (isPrime(i)) primes.push_back(i); } return primes; }",
    "tạo một chuỗi từ một vector các ký tự": "std::string vectorToString(const std::vector<char>& vec) { return std::string(vec.begin(), vec.end()); }",
    "tìm tất cả các số nguyên tố trong một vector": "std::vector<int> findPrimesInVector(const std::vector<int>& vec) { std::vector<int> primes; for (int num : vec) { if (isPrime(num)) primes.push_back(num); } return primes; }",
    "tính tổng các phần tử trong một vector với giá trị khởi đầu": "int sumWithInitial(const std::vector<int>& vec, int initial) { return std::accumulate(vec.begin(), vec.end(), initial); }",
    "chèn một phần tử vào đầu vector": "void prependToVector(std::vector<int>& vec, int value) { vec.insert(vec.begin(), value); }",
    "chèn một phần tử vào cuối vector": "void appendToVector(std::vector<int>& vec, int value) { vec.push_back(value); }",
    "xóa phần tử đầu tiên trong vector": "void removeFirstElement(std::vector<int>& vec) { if (!vec.empty()) vec.erase(vec.begin()); }",
    "xóa phần tử cuối cùng trong vector": "void removeLastElement(std::vector<int>& vec) { if (!vec.empty()) vec.pop_back(); }",
    "tạo một vector chứa số Fibonacci từ 0 đến n": "std::vector<int> fibonacciSequence(int n) { std::vector<int> fib = {0, 1}; while (true) { int next = fib.back() + *(fib.end() - 2); if (next > n) break; fib.push_back(next); } return fib; }",
    "chèn một phần tử vào vị trí cụ thể trong vector": "void insertAtPosition(std::vector<int>& vec, int value, size_t position) { if (position <= vec.size()) vec.insert(vec.begin() + position, value); }",
    "tính giá trị trung bình của các số trong một vector với một giá trị khởi đầu": "double averageWithInitial(const std::vector<int>& vec, double initial) { double sum = initial; for (int num : vec) sum += num; return sum / (vec.size() + 1); }",
    "tạo một vector từ các số nguyên tố trong một khoảng": "std::vector<int> primesInRange(int start, int end) { std::vector<int> primes; for (int i = start; i <= end; ++i) { if (isPrime(i)) primes.push_back(i); } return primes; }",
    "tính số lượng ký tự cụ thể trong chuỗi": "int countCharacter(const std::string& str, char ch) { return std::count(str.begin(), str.end(), ch); }",
    "đếm số lượng từ trong chuỗi": "int wordCount(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "kiểm tra xem vector có chứa một phần tử nhất định không": "bool containsElement(const std::vector<int>& vec, int value) { return std::find(vec.begin(), vec.end(), value) != vec.end(); }",
    "trộn hai vector thành một vector mới": "std::vector<int> mergeVectors(const std::vector<int>& v1, const std::vector<int>& v2) { std::vector<int> merged(v1); merged.insert(merged.end(), v2.begin(), v2.end()); return merged; }",
    "tạo một vector với các số nguyên từ 1 đến n với bước nhảy k": "std::vector<int> createSequence(int n, int k) { std::vector<int> seq; for (int i = 1; i <= n; i += k) seq.push_back(i); return seq; }",
    "tạo một chuỗi từ một vector các số nguyên": "std::string vectorToString(const std::vector<int>& vec) { std::ostringstream oss; for (int num : vec) oss << num << ' '; return oss.str(); }",
    "kiểm tra xem vector có trùng lặp phần tử không": "bool hasDuplicates(const std::vector<int>& vec) { std::set<int> seen; for (int num : vec) { if (!seen.insert(num).second) return true; } return false; }",
    "thay thế tất cả các phần tử trong vector bằng một giá trị mới": "void replaceAllElements(std::vector<int>& vec, int newValue) { std::fill(vec.begin(), vec.end(), newValue); }",
    "đảo ngược thứ tự các phần tử trong vector": "void reverseVector(std::vector<int>& vec) { std::reverse(vec.begin(), vec.end()); }",
    "kiểm tra xem chuỗi có chứa ký tự đặc biệt không": "bool containsSpecialChar(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char ch) { return !std::isalnum(ch) && !std::isspace(ch); }); }",
    "tìm số nhỏ nhất trong vector": "int minInVector(const std::vector<int>& vec) { return *std::min_element(vec.begin(), vec.end()); }",
    "tìm số lớn nhất trong vector": "int maxInVector(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "tính tổng các số chẵn trong vector": "int sumEvenNumbers(const std::vector<int>& vec) { int sum = 0; for (int num : vec) { if (num % 2 == 0) sum += num; } return sum; }",
    "tính tổng các số lẻ trong vector": "int sumOddNumbers(const std::vector<int>& vec) { int sum = 0; for (int num : vec) { if (num % 2 != 0) sum += num; } return sum; }",
    "kiểm tra xem tất cả các phần tử trong vector có lớn hơn một giá trị không": "bool allGreaterThan(const std::vector<int>& vec, int value) { return std::all_of(vec.begin(), vec.end(), [value](int num) { return num > value; }); }",
    "kiểm tra xem có ít nhất một phần tử trong vector lớn hơn một giá trị không": "bool anyGreaterThan(const std::vector<int>& vec, int value) { return std::any_of(vec.begin(), vec.end(), [value](int num) { return num > value; }); }",
    "tìm phần tử nhỏ nhất lớn hơn một giá trị trong vector": "int findMinGreaterThan(const std::vector<int>& vec, int value) { auto it = std::find_if(vec.begin(), vec.end(), [value](int num) { return num > value; }); return it != vec.end() ? *it : -1; }",
    "tạo một chuỗi từ một vector các chuỗi": "std::string joinStrings(const std::vector<std::string>& vec, const std::string& delimiter) { return std::accumulate(vec.begin(), vec.end(), std::string(), [&delimiter](const std::string& a, const std::string& b) { return a.empty() ? b : a + delimiter + b; }); }",
    "tạo một vector từ một chuỗi số nguyên cách nhau bởi dấu phẩy": "std::vector<int> parseIntVector(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ',')) vec.push_back(std::stoi(item)); return vec; }",
    "tính số lượng ký tự trong chuỗi": "int characterCount(const std::string& str) { return str.size(); }",
    "tạo một chuỗi từ một vector các số nguyên, ngăn cách bởi dấu gạch chéo": "std::string vectorToStringSlash(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ các số nguyên theo mẫu từ 0 đến n với bước nhảy 2": "std::vector<int> createEvenSequence(int n) { std::vector<int> seq; for (int i = 0; i <= n; i += 2) seq.push_back(i); return seq; }",
    "tạo một vector từ các số nguyên theo mẫu từ 1 đến n với bước nhảy 3": "std::vector<int> createSequenceStep3(int n) { std::vector<int> seq; for (int i = 1; i <= n; i += 3) seq.push_back(i); return seq; }",
    "tìm tất cả các chỉ số của một phần tử trong vector": "std::vector<int> findAllIndices(const std::vector<int>& vec, int value) { std::vector<int> indices; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] == value) indices.push_back(i); } return indices; }",
    "kiểm tra xem một chuỗi có phải là một số nguyên không": "bool isInteger(const std::string& str) { return std::all_of(str.begin(), str.end(), [](char ch) { return std::isdigit(ch) || ch == '-'; }); }",
    "kiểm tra xem một chuỗi có phải là số thực không": "bool isFloatingPoint(const std::string& str) { std::istringstream iss(str); double d; char c; return !(iss >> d).fail() && !(iss >> c).fail(); }",
    "tạo một chuỗi từ các ký tự trong vector": "std::string vectorToCharString(const std::vector<char>& vec) { return std::string(vec.begin(), vec.end()); }",
    "tìm số nguyên tố nhỏ nhất trong một vector": "int minPrime(const std::vector<int>& vec) { auto it = std::find_if(vec.begin(), vec.end(), [](int num) { return isPrime(num); }); return it != vec.end() ? *it : -1; }",
    "tạo một vector chứa các số chẵn từ 1 đến n": "std::vector<int> evenNumbers(int n) { std::vector<int> result; for (int i = 2; i <= n; i += 2) result.push_back(i); return result; }",
    "kiểm tra xem một chuỗi có chứa một ký tự cụ thể không": "bool containsChar(const std::string& str, char ch) { return str.find(ch) != std::string::npos; }",
    "tính số lượng ký tự khác nhau trong một chuỗi": "std::unordered_map<char, int> countUniqueChars(const std::string& str) { std::unordered_map<char, int> charCount; for (char ch : str) ++charCount[ch]; return charCount; }",
    "tạo một vector từ một chuỗi ký tự phân cách bằng dấu chấm phẩy": "std::vector<std::string> splitBySemicolon(const std::string& str) { std::vector<std::string> result; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ';')) result.push_back(item); return result; }",
    "tìm tất cả các số nguyên tố trong một khoảng từ 1 đến n": "std::vector<int> findPrimes(int n) { std::vector<int> primes; if (n >= 2) primes.push_back(2); for (int i = 3; i <= n; i += 2) { bool isPrime = true; for (int p : primes) { if (p * p > i) break; if (i % p == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(i); } return primes; }",
    "chèn một phần tử vào một vị trí cụ thể trong vector": "void insertIntoVector(std::vector<int>& vec, int value, size_t position) { if (position <= vec.size()) vec.insert(vec.begin() + position, value); }",
    "tạo một chuỗi với tất cả các ký tự từ một vector và thêm dấu cách giữa chúng": "std::string vectorToStringSpace(const std::vector<char>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ' '; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một vector các số nguyên thành một chuỗi các số thập phân với dấu phân cách bằng dấu phẩy": "std::string vectorToDecimalString(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << std::fixed << std::setprecision(2) << static_cast<double>(vec[i]); } return oss.str(); }",
    "tạo một vector các số nguyên từ một chuỗi ký tự phân cách bằng dấu gạch chéo": "std::vector<int> parseIntFromSlashDelimitedString(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, '/')) vec.push_back(std::stoi(item)); return vec; }",
    "tính tổng các số nguyên trong chuỗi phân cách bằng dấu cách": "int sumFromSpaceDelimitedString(const std::string& str) { std::istringstream iss(str); int sum = 0, num; while (iss >> num) sum += num; return sum; }",
    "kiểm tra xem một chuỗi có chứa một chuỗi con không, bất kể chữ hoa hay chữ thường": "bool containsIgnoreCase(const std::string& str, const std::string& sub) { std::string strLower = toLowerCase(str); std::string subLower = toLowerCase(sub); return strLower.find(subLower) != std::string::npos; }",
    "tạo một chuỗi từ các ký tự của vector theo mẫu phân cách bằng dấu chấm": "std::string vectorToStringDot(const std::vector<char>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '.'; oss << vec[i]; } return oss.str(); }",
    "kiểm tra xem một số có phải là số Fibonacci không": "bool isFibonacci(int num) { if (num < 0) return false; int a = 0, b = 1; while (b < num) { int temp = a; a = b; b = temp + b; } return b == num; }",
    "tạo một chuỗi từ một vector các số nguyên, phân cách bằng dấu hai chấm": "std::string vectorToStringColon(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ':'; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành một vector các số nguyên, phân cách bằng dấu phẩy": "std::vector<int> parseIntFromCommaDelimitedString(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ',')) vec.push_back(std::stoi(item)); return vec; }",
    "tạo một chuỗi từ một vector các số nguyên theo mẫu phân cách bằng dấu gạch chéo": "std::string vectorToStringSlash(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "kiểm tra xem một chuỗi có phải là số thực không": "bool isFloat(const std::string& str) { std::istringstream iss(str); float f; return iss >> f && iss.eof(); }",
    "tạo một vector từ một dãy số liên tiếp từ 1 đến n": "std::vector<int> createSequentialVector(int n) { std::vector<int> vec; for (int i = 1; i <= n; ++i) vec.push_back(i); return vec; }",
    "chuyển một chuỗi thành tất cả chữ hoa": "std::string toUpperCase(const std::string& str) { std::string result = str; std::transform(result.begin(), result.end(), result.begin(), ::toupper); return result; }",
    "tìm phần tử lớn nhất trong một vector số nguyên": "int findMaxInVector(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "tính tổng các số trong một vector": "int sumVector(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0); }",
    "chuyển đổi một chuỗi thành vector các ký tự, phân cách bởi dấu gạch ngang": "std::vector<char> parseCharsFromString(const std::string& str) { std::vector<char> vec(str.begin(), str.end()); return vec; }",
    "tạo một chuỗi từ một vector số nguyên và chèn dấu phân cách tùy chỉnh": "std::string vectorToStringWithDelimiter(const std::vector<int>& vec, char delimiter) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << delimiter; oss << vec[i]; } return oss.str(); }",
    "kiểm tra một chuỗi có phải là số nguyên không": "bool isInteger(const std::string& str) { std::istringstream iss(str); int i; return iss >> i && iss.eof(); }",
    "tạo một vector chứa các số lẻ từ 1 đến n": "std::vector<int> oddNumbers(int n) { std::vector<int> result; for (int i = 1; i <= n; i += 2) result.push_back(i); return result; }",
    "tìm số nhỏ nhất trong một vector số thực": "float findMinInFloatVector(const std::vector<float>& vec) { return *std::min_element(vec.begin(), vec.end()); }",
    "chèn một phần tử vào cuối của vector": "void appendToVector(std::vector<int>& vec, int value) { vec.push_back(value); }",
    "tạo một chuỗi từ một vector các ký tự và loại bỏ khoảng trắng": "std::string vectorToStringNoSpaces(const std::vector<char>& vec) { std::string result(vec.begin(), vec.end()); result.erase(std::remove(result.begin(), result.end(), ' '), result.end()); return result; }",
    "tính tổng các số thực trong một vector": "float sumFloatVector(const std::vector<float>& vec) { return std::accumulate(vec.begin(), vec.end(), 0.0f); }",
    "tạo một vector từ một chuỗi ký tự phân cách bằng dấu chấm phẩy và chuyển các phần tử thành chữ hoa": "std::vector<std::string> splitAndUppercase(const std::string& str) { std::vector<std::string> result; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ';')) { std::transform(item.begin(), item.end(), item.begin(), ::toupper); result.push_back(item); } return result; }",
    "kiểm tra xem một chuỗi có chứa chỉ số nguyên không": "bool containsOnlyIntegers(const std::string& str) { return std::all_of(str.begin(), str.end(), ::isdigit); }",
    "tạo một vector từ một chuỗi các số nguyên phân cách bằng dấu phẩy và chuyển đổi thành số thực": "std::vector<float> parseFloatFromCommaDelimitedString(const std::string& str) { std::vector<float> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ',')) vec.push_back(std::stof(item)); return vec; }",
    "tính số lượng từ trong một chuỗi": "size_t countWords(const std::string& str) { std::istringstream iss(str); return std::distance(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>()); }",
    "kiểm tra một chuỗi có phải là số thực không, bao gồm dấu chấm thập phân": "bool isFloatingPoint(const std::string& str) { std::istringstream iss(str); float f; return (iss >> f) && (iss.eof() || iss.peek() == std::istream::traits_type::eof()); }",
    "tạo một chuỗi từ một vector số nguyên, phân cách bằng dấu gạch chéo và xóa các số trùng lặp": "std::string vectorToStringUniqueSlash(const std::vector<int>& vec) { std::unordered_set<int> uniqueSet(vec.begin(), vec.end()); std::ostringstream oss; for (auto it = uniqueSet.begin(); it != uniqueSet.end(); ++it) { if (it != uniqueSet.begin()) oss << '/'; oss << *it; } return oss.str(); }",
    "chuyển đổi một số nguyên thành chuỗi nhị phân": "std::string intToBinary(int num) { std::string result; while (num > 0) { result = std::to_string(num % 2) + result; num /= 2; } return result.empty() ? '0' : result; }",
    "đảo ngược một chuỗi": "std::string reverseString(const std::string& str) { return std::string(str.rbegin(), str.rend()); }",
    "kiểm tra một chuỗi có phải là palindrome không": "bool isPalindrome(const std::string& str) { std::string reversed = reverseString(str); return str == reversed; }",
    "tính trung bình của các số trong một vector": "double averageVector(const std::vector<int>& vec) { return static_cast<double>(std::accumulate(vec.begin(), vec.end(), 0)) / vec.size(); }",
    "tạo một vector từ một dãy số thực liên tiếp từ 1.0 đến n.0": "std::vector<float> createSequentialFloatVector(int n) { std::vector<float> vec; for (int i = 1; i <= n; ++i) vec.push_back(static_cast<float>(i)); return vec; }",
    "tính giai thừa của một số nguyên dương": "long long factorial(int n) { return (n <= 1) ? 1 : n * factorial(n - 1); }",
    "tính Fibonacci của một số nguyên dương": "std::vector<int> fibonacci(int n) { std::vector<int> sequence = {0, 1}; for (int i = 2; i < n; ++i) { sequence.push_back(sequence[i - 1] + sequence[i - 2]); } return sequence; }",
    "tạo một chuỗi từ một vector các số nguyên, phân cách bằng dấu chấm phẩy": "std::string vectorToStringSemicolon(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ';'; oss << vec[i]; } return oss.str(); }",
    "tạo một vector chứa các số chẵn từ 0 đến n": "std::vector<int> evenNumbers(int n) { std::vector<int> result; for (int i = 0; i <= n; i += 2) result.push_back(i); return result; }",
    "chèn một phần tử vào vị trí cụ thể trong vector": "void insertIntoVector(std::vector<int>& vec, int index, int value) { if (index >= 0 && index <= vec.size()) vec.insert(vec.begin() + index, value); }",
    "tạo một vector từ một dãy số thực liên tiếp và làm tròn đến số nguyên gần nhất": "std::vector<int> roundFloatVector(const std::vector<float>& vec) { std::vector<int> result; result.reserve(vec.size()); for (float num : vec) result.push_back(static_cast<int>(std::round(num))); return result; }",
    "kiểm tra xem một chuỗi có phải là số âm không": "bool isNegativeNumber(const std::string& str) { return !str.empty() && str[0] == '-'; }",
    "tạo một chuỗi từ một vector các ký tự và giữ lại chỉ các ký tự chữ cái": "std::string filterLetters(const std::vector<char>& vec) { std::string result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), ::isalpha); return result; }",
    "chuyển một vector các số nguyên thành vector các số thực với giá trị gấp đôi": "std::vector<float> doubleVectorValues(const std::vector<int>& vec) { std::vector<float> result; result.reserve(vec.size()); for (int num : vec) result.push_back(num * 2.0f); return result; }",
    "tạo một chuỗi từ một vector số nguyên và thêm một dấu cách giữa các số": "std::string vectorToStringWithSpaces(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ' '; oss << vec[i]; } return oss.str(); }",
    "tìm tất cả các số nguyên tố trong một khoảng từ 1 đến n": "std::vector<int> findPrimes(int n) { std::vector<int> primes; for (int num = 2; num <= n; ++num) { bool isPrime = true; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) primes.push_back(num); } return primes; }",
    "tạo một vector chứa các phần tử của một vector gốc lớn hơn giá trị cho trước": "std::vector<int> filterGreaterThan(const std::vector<int>& vec, int threshold) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [threshold](int num) { return num > threshold; }); return result; }",
    "tính tổng các phần tử trong một vector sử dụng hàm lambda": "int sumVectorLambda(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int a, int b) { return a + b; }); }",
    "chuyển đổi một chuỗi thành số thực, bao gồm dấu chấm thập phân và kiểm tra tính hợp lệ": "bool tryParseFloat(const std::string& str, float& result) { std::istringstream iss(str); return !(iss >> result).fail(); }",
    "tính số lượng các ký tự chữ cái trong một chuỗi": "size_t countAlphabeticChars(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isalpha); }",
    "tạo một vector từ một chuỗi số nguyên phân cách bằng dấu gạch ngang và chuyển đổi thành số nguyên": "std::vector<int> parseIntsFromDashDelimitedString(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, '-')) vec.push_back(std::stoi(item)); return vec; }",
    "chuyển một chuỗi thành vector các từ, phân cách bởi dấu cách và loại bỏ các từ trùng lặp": "std::vector<std::string> uniqueWords(const std::string& str) { std::istringstream iss(str); std::set<std::string> uniqueSet((std::istream_iterator<std::string>(iss)), std::istream_iterator<std::string>()); return std::vector<std::string>(uniqueSet.begin(), uniqueSet.end()); }",
    "tính tổng của tất cả các số trong một vector": "int sumVector(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0); }",
    "chuyển đổi một chuỗi thành số nguyên với kiểm tra lỗi": "bool tryParseInt(const std::string& str, int& result) { std::istringstream iss(str); return !(iss >> result).fail(); }",
    "tính số lượng các ký tự số trong một chuỗi": "size_t countDigits(const std::string& str) { return std::count_if(str.begin(), str.end(), ::isdigit); }",
    "chèn một ký tự vào vị trí cụ thể trong chuỗi": "std::string insertCharAt(const std::string& str, size_t pos, char c) { std::string result = str; result.insert(pos, 1, c); return result; }",
    "tạo một vector từ một chuỗi các số phân cách bởi dấu phẩy": "std::vector<int> parseIntsFromCommaDelimitedString(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; while (std::getline(iss, item, ',')) vec.push_back(std::stoi(item)); return vec; }",
    "tính căn bậc hai của một số thực": "double squareRoot(double num) { return std::sqrt(num); }",
    "tạo một vector chứa các số nguyên tố trong một khoảng từ a đến b": "std::vector<int> findPrimesInRange(int a, int b) { std::vector<int> primes; for (int num = a; num <= b; ++num) { bool isPrime = true; for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime && num > 1) primes.push_back(num); } return primes; }",
    "kiểm tra một chuỗi có chứa một ký tự đặc biệt không": "bool containsSpecialChar(const std::string& str) { return std::any_of(str.begin(), str.end(), [](char c) { return !std::isalnum(c) && !std::isspace(c); }); }",
    "chuyển một vector các số nguyên thành chuỗi phân cách bởi dấu gạch chéo": "std::string vectorToStringWithSlashes(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các ký tự, phân cách bởi dấu gạch ngang": "std::string vectorToStringWithHyphens(const std::vector<char>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '-'; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi và chuyển tất cả các ký tự thành chữ hoa": "std::vector<char> toUpperCaseVector(const std::string& str) { std::vector<char> vec(str.begin(), str.end()); std::transform(vec.begin(), vec.end(), vec.begin(), ::toupper); return vec; }",
    "tạo một chuỗi từ một vector các số thực, phân cách bằng dấu phẩy và giữ lại hai chữ số thập phân": "std::string vectorToStringWithFloat(const std::vector<float>& vec) { std::ostringstream oss; oss.precision(2); oss << std::fixed; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ', '; oss << vec[i]; } return oss.str(); }",
    "kiểm tra một chuỗi có phải là số nguyên dương không": "bool isPositiveInteger(const std::string& str) { if (str.empty()) return false; return std::all_of(str.begin(), str.end(), ::isdigit) && std::stoi(str) > 0; }",
    "tạo một vector chứa các số nguyên từ 1 đến n, nhưng loại bỏ các số chia hết cho m": "std::vector<int> filterMultiples(const std::vector<int>& vec, int m) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [m](int num) { return num % m != 0; }); return result; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu cách giữa các số": "std::string vectorToStringWithSpaces(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ' '; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực và loại bỏ các số âm": "std::vector<float> parsePositiveFloats(const std::string& str) { std::vector<float> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một vector chứa các số nguyên từ 1 đến n, loại bỏ các số không phải số nguyên tố": "std::vector<int> filterNonPrimes(const std::vector<int>& vec) { std::vector<int> result; for (int num : vec) { bool isPrime = true; if (num < 2) isPrime = false; else for (int i = 2; i <= std::sqrt(num); ++i) { if (num % i == 0) { isPrime = false; break; } } if (isPrime) result.push_back(num); } return result; }",
    "tạo một chuỗi từ một vector các ký tự, loại bỏ các ký tự số": "std::string filterNonDigits(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), [](char c) { return !std::isdigit(c); }); return result; }",
    "chuyển đổi một số nguyên thành chuỗi nhị phân và thêm tiền tố '0b'": "std::string intToBinaryWithPrefix(int num) { std::string result = intToBinary(num); return '0b' + result; }",
    "tạo một vector từ một chuỗi các số thực phân cách bởi dấu phẩy và làm tròn đến số nguyên gần nhất": "std::vector<int> parseAndRoundFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::round(num)); } return vec; }",
    "chèn một chuỗi vào một chuỗi khác tại một vị trí cụ thể": "std::string insertStringAt(const std::string& base, size_t pos, const std::string& toInsert) { std::string result = base; result.insert(pos, toInsert); return result; }",
    "tính tổng các số nguyên dương trong một vector": "int sumPositiveIntegers(const std::vector<int>& vec) { return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, int num) { return num > 0 ? sum + num : sum; }); }",
    "tạo một vector từ một chuỗi và loại bỏ các ký tự trùng lặp": "std::vector<char> uniqueChars(const std::string& str) { std::set<char> uniqueSet(str.begin(), str.end()); return std::vector<char>(uniqueSet.begin(), uniqueSet.end()); }",
    "tạo một chuỗi từ một vector các số thực và thêm dấu chấm thập phân nếu cần thiết": "std::string vectorToStringWithDecimal(const std::vector<float>& vec) { std::ostringstream oss; oss << std::fixed << std::setprecision(2); for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "kiểm tra xem một số nguyên có phải là số chính phương không": "bool isPerfectSquare(int num) { int root = static_cast<int>(std::sqrt(num)); return root * root == num; }",
    "chuyển đổi một chuỗi thành vector các số nguyên và sắp xếp theo thứ tự giảm dần": "std::vector<int> parseAndSortDescending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "tạo một chuỗi từ một vector các ký tự và chuyển tất cả các ký tự thành chữ thường": "std::string toLowerCaseString(const std::vector<char>& vec) { std::string result(vec.begin(), vec.end()); std::transform(result.begin(), result.end(), result.begin(), ::tolower); return result; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm một dấu phẩy sau mỗi số và loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithTrailingComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ', '; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi các số nguyên phân cách bởi dấu chấm và tăng mỗi số lên 1": "std::vector<int> parseAndIncrement(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(num + 1); } return vec; }",
    "chuyển đổi một số thực thành chuỗi và thêm tiền tố 'f'": "std::string floatToStringWithPrefix(float num) { std::ostringstream oss; oss << num; return 'f' + oss.str(); }",
    "kiểm tra xem một chuỗi có phải là số thực không": "bool isFloat(const std::string& str) { std::istringstream iss(str); float num; return !(iss >> num).fail(); }",
    "tạo một vector từ một chuỗi và sắp xếp các số nguyên theo thứ tự tăng dần": "std::vector<int> parseAndSortAscending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end()); return vec; }",
    "chuyển đổi một chuỗi thành vector các số thực và làm tròn đến số nguyên gần nhất": "std::vector<int> parseAndRoundToInt(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::round(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu gạch chéo sau mỗi số": "std::string vectorToStringWithSlashes(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "tạo một vector chứa các số nguyên từ 1 đến n, loại bỏ các số không chia hết cho k": "std::vector<int> filterMultiplesOfK(const std::vector<int>& vec, int k) { std::vector<int> result; std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [k](int num) { return num % k == 0; }); return result; }",
    "chuyển đổi một chuỗi thành vector các số nguyên và loại bỏ số không chia hết cho m": "std::vector<int> parseAndFilterMultiples(const std::string& str, int m) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num % m == 0) vec.push_back(num); } return vec; }",
    "tạo một vector từ một chuỗi và sắp xếp các số nguyên theo thứ tự giảm dần": "std::vector<int> parseAndSortDescending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "tạo một chuỗi từ một vector các ký tự, loại bỏ các ký tự không phải chữ cái": "std::string filterNonAlphabetic(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), ::isalpha); return result; }",
    "tạo một vector từ một chuỗi các số thực phân cách bởi dấu chấm và làm tròn đến số nguyên gần nhất": "std::vector<int> parseAndRoundToIntFromDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::round(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm tiền tố 'num-'": "std::string vectorToStringWithNumPrefix(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'num-' << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi và thêm tiền tố vào mỗi số nguyên": "std::vector<std::string> addPrefixToEachNumber(const std::string& str, const std::string& prefix) { std::vector<std::string> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(prefix + std::to_string(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên, sắp xếp theo thứ tự giảm dần và thêm một dấu chấm sau mỗi số": "std::string vectorToStringWithDots(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '.'; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu cách sau mỗi số": "std::string vectorToStringWithSpacesAfterEach(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ' '; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi và sắp xếp các số nguyên theo thứ tự giảm dần, loại bỏ số trùng lặp": "std::vector<int> parseAndSortUniqueDescending(const std::string& str) { std::set<int> uniqueSet; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) uniqueSet.insert(num); } std::vector<int> vec(uniqueSet.begin(), uniqueSet.end()); std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "tạo một chuỗi từ một vector các ký tự và loại bỏ các ký tự trùng lặp": "std::string removeDuplicateChars(const std::string& str) { std::string result; std::unordered_set<char> seen; for (char c : str) { if (seen.insert(c).second) result += c; } return result; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm dấu chấm sau mỗi số, loại bỏ dấu chấm cuối cùng": "std::string vectorToStringWithTrailingDot(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '.'; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn lên": "std::vector<int> parseAndCeilFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "tạo một vector từ một chuỗi và sắp xếp các số nguyên theo thứ tự tăng dần, loại bỏ số trùng lặp": "std::vector<int> parseAndSortUniqueAscending(const std::string& str) { std::set<int> uniqueSet; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) uniqueSet.insert(num); } std::vector<int> vec(uniqueSet.begin(), uniqueSet.end()); std::sort(vec.begin(), vec.end()); return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu gạch chéo sau mỗi số, loại bỏ dấu gạch chéo cuối cùng": "std::string vectorToStringWithTrailingSlash(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn đến số nguyên gần nhất, loại bỏ các số âm": "std::vector<int> parseAndRoundPositiveFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(std::round(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm một dấu gạch chéo sau mỗi số và loại bỏ dấu gạch chéo cuối cùng": "std::string vectorToStringWithTrailingSlash(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '/'; oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên và loại bỏ số 0": "std::string removeZeroesFromVector(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] != 0) { if (i > 0) oss << ','; oss << vec[i]; } } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên, lọc các số chia hết cho k": "std::vector<int> parseAndFilterDivisibleByK(const std::string& str, int k) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num % k == 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'num-' và loại bỏ số 0": "std::string vectorToStringWithNumPrefixRemoveZero(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] != 0) { if (i > 0) oss << ','; oss << 'num-' << vec[i]; } } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên và loại bỏ dấu phân cách giữa các số": "std::string vectorToStringWithoutSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các ký tự và loại bỏ các ký tự không phải chữ cái và số": "std::string filterNonAlphanumeric(const std::string& str) { std::string result; std::copy_if(str.begin(), str.end(), std::back_inserter(result), ::isalnum); return result; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefix(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực và làm tròn đến số nguyên gần nhất, loại bỏ số âm": "std::vector<int> parseAndRoundPositiveFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(std::round(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên và thêm một dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên, loại bỏ số âm và sắp xếp theo thứ tự giảm dần": "std::vector<int> parseAndSortNonNegativeDescending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu chấm và sắp xếp theo thứ tự tăng dần": "std::vector<int> parseAndSortAscending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end()); return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và sắp xếp theo thứ tự giảm dần": "std::vector<int> parseAndSortDescending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end(), std::greater<int>()); return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu phẩy và sắp xếp theo thứ tự tăng dần": "std::vector<int> parseAndSortAscending(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } std::sort(vec.begin(), vec.end()); return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu chấm và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegativeFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegative(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên, loại bỏ số âm và loại bỏ dấu phân cách": "std::string vectorToStringWithoutSeparatorRemoveNegative(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] >= 0) oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu chấm và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegativeFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, loại bỏ số âm và loại bỏ dấu phân cách": "std::string vectorToStringWithoutSeparatorRemoveNegative(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] >= 0) oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegative(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, loại bỏ số âm và loại bỏ dấu phân cách": "std::string vectorToStringWithoutSeparatorRemoveNegative(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] >= 0) oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, loại bỏ số âm và loại bỏ dấu phân cách": "std::string vectorToStringWithoutSeparatorRemoveNegative(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (vec[i] >= 0) oss << vec[i]; } return oss.str(); }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegative(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên và thêm dấu phẩy sau mỗi số, loại bỏ dấu phẩy cuối cùng": "std::string vectorToStringWithComma(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu chấm và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegativeFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloats(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'number-' và giữ dấu phân cách": "std::string vectorToStringWithNumberPrefixKeepSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '|'; oss << 'number-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tìm giá trị lớn nhất trong một vector": "int maxInVector(const std::vector<int>& vec) { return *std::max_element(vec.begin(), vec.end()); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu gạch chéo và làm tròn lên": "std::vector<int> parseAndCeilFloatsBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'value-' và loại bỏ dấu phân cách cuối cùng": "std::string vectorToStringWithValuePrefixRemoveLastSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'value-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu phẩy và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegativeByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm dấu phân cách '-' và giữ dấu phân cách cuối cùng": "std::string vectorToStringWithDashSeparatorKeepLast(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '-'; oss << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách": "std::string vectorToStringWithItemPrefixRemoveSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn xuống": "std::vector<int> parseAndFloorFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và loại bỏ các số âm": "std::vector<int> parseAndRemoveNegativeBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'num-' và loại bỏ dấu phân cách cuối cùng": "std::string vectorToStringWithNumPrefixRemoveLastSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'num-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và làm tròn lên": "std::vector<int> parseAndCeilIntsBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'item-' và giữ dấu phân cách": "std::string vectorToStringWithItemPrefixKeepSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu gạch chéo và làm tròn lên": "std::vector<int> parseAndCeilFloatsBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorIntsByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'value-' và giữ tất cả số nguyên": "std::string vectorToStringWithValuePrefixKeepAll(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'value-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu gạch chéo và làm tròn xuống": "std::vector<int> parseAndFloorFloatsBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'data-' và giữ dấu phân cách cuối cùng": "std::string vectorToStringWithDataPrefixKeepLastSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'data-' << vec[i]; } return oss.str(); }",
    "chuyển đổi một chuỗi thành vector các số nguyên phân cách bởi dấu gạch chéo và loại bỏ số âm": "std::vector<int> parseAndRemoveNegativeBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num && num >= 0) vec.push_back(num); } return vec; }",
    "tạo một chuỗi từ một vector các ký tự, loại bỏ tất cả ký tự không phải chữ cái và số": "std::string filterAlphanumeric(const std::vector<char>& vec) { std::string result; for (char c : vec) if (std::isalnum(c)) result += c; return result; }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloatsByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo một chuỗi từ một vector các số nguyên, thêm tiền tố 'number-' và loại bỏ dấu phân cách cuối cùng": "std::string vectorToStringWithNumberPrefixRemoveLastSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'number-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu gạch ngang và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '-')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo chuỗi từ vector số nguyên, thêm tiền tố 'element-' và giữ tất cả số nguyên": "std::string vectorToStringWithElementPrefixKeepAll(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'element-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu chấm phẩy và làm tròn xuống": "std::vector<int> parseAndFloorFloatsBySemicolon(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ';')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo chuỗi từ vector ký tự, thêm tiền tố 'char-' và loại bỏ ký tự trắng": "std::string vectorToStringWithCharPrefixRemoveWhitespace(const std::vector<char>& vec) { std::string result; for (char c : vec) { if (!std::isspace(c)) result += 'char-' + std::string(1, c); } return result; }",
    "chuyển đổi chuỗi thành vector số nguyên phân cách bởi dấu hai chấm và giữ số âm": "std::vector<int> parseAndKeepNegativeByColon(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ':')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo chuỗi từ vector số thực, thêm tiền tố 'float-' và giữ dấu phân cách chấm": "std::string vectorToStringWithFloatPrefixKeepDot(const std::vector<float>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '.'; oss << 'float-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu gạch chéo và làm tròn xuống": "std::vector<int> parseAndFloorFloatsBySlash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(std::floor(num)); } return vec; }",
    "tạo chuỗi từ vector số nguyên, thêm tiền tố 'value-' và giữ tất cả số nguyên và dấu phân cách": "std::string vectorToStringWithValuePrefixKeepAllAndSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'value-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số nguyên phân cách bởi dấu gạch ngang và giữ số âm": "std::vector<int> parseAndKeepNegativeByDash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '-')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo chuỗi từ vector số thực, thêm tiền tố 'float-' và loại bỏ dấu phân cách cuối cùng": "std::string vectorToStringWithFloatPrefixRemoveLastSeparator(const std::vector<float>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'float-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số nguyên phân cách bởi dấu phẩy và làm tròn xuống": "std::vector<int> parseAndFloorIntsByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu chấm và giữ số âm": "std::vector<float> parseAndKeepNegativeFloatsByDot(const std::string& str) { std::vector<float> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo chuỗi từ vector số nguyên, thêm tiền tố 'item-' và giữ dấu phân cách chấm": "std::string vectorToStringWithItemPrefixKeepDot(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '.'; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu gạch chéo và giữ số âm": "std::vector<float> parseAndKeepNegativeFloatsBySlash(const std::string& str) { std::vector<float> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '/')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo chuỗi từ vector số nguyên, thêm tiền tố 'number-' và giữ tất cả số nguyên và dấu phân cách": "std::string vectorToStringWithNumberPrefixKeepAllAndSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'number-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu gạch ngang và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDash(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '-')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "chuyển đổi chuỗi thành vector số nguyên phân cách bởi dấu chấm và giữ số âm": "std::vector<int> parseAndKeepNegativeIntsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; int num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(num); } return vec; }",
    "tạo chuỗi từ vector số thực, thêm tiền tố 'float-' và giữ dấu phân cách gạch ngang": "std::string vectorToStringWithFloatPrefixKeepDash(const std::vector<float>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << '-'; oss << 'float-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu chấm phẩy và làm tròn lên": "std::vector<int> parseAndCeilFloatsBySemicolon(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ';')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "tạo chuỗi từ vector số nguyên, thêm tiền tố 'item-' và loại bỏ dấu phân cách cuối cùng": "std::string vectorToStringWithItemPrefixRemoveLastSeparator(const std::vector<int>& vec) { std::ostringstream oss; for (size_t i = 0; i < vec.size(); ++i) { if (i > 0) oss << ','; oss << 'item-' << vec[i]; } return oss.str(); }",
    "chuyển đổi chuỗi thành vector số thực phân cách bởi dấu chấm và làm tròn lên": "std::vector<int> parseAndCeilFloatsByDot(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, '.')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }",
    "chuyển đổi một chuỗi thành vector các số thực phân cách bởi dấu phẩy và làm tròn lên": "std::vector<int> parseAndCeilFloatsByComma(const std::string& str) { std::vector<int> vec; std::istringstream iss(str); std::string item; float num; while (std::getline(iss, item, ',')) { if (std::istringstream(item) >> num) vec.push_back(std::ceil(num)); } return vec; }"







































}
    